<html>
	<head>
		<link rel="stylesheet" type="text/css" href="minireset.css">
		<style type="text/css">
			html, body{
				height: 100%;
				overflow: hidden;
			}
			#canvas{
				width: 100%;
				height: 100%;
				cursor: crosshair;
			}
			#menus{
				border: 1px solid black;
				height: 100%;
				background-size: cover;
				background-repeat: no-repeat;
				background-image: url('images/monitor.jpg');
			}
			.menu{
				margin-left: 15%;
				margin-top: 6%;
			}
			.mainTitle{
				font-size: 500%;
				font-family: "impact";
			}
			#pauseMenuOuter{
				display: none;
				background-color: rgba(0, 0, 0, 0.75);
				z-index: 10;
				position: absolute;
				width: 100%;
				height: 100%;
				align-items: center;
			}
			#pauseMenu{
				background-color: rgba(255, 255, 255, 0.25);
				z-index: 11;
				margin-left: auto;
				margin-right: auto;
				width: 800;
			}
			.menuTitle{
				font-size: 500%;
				font-family: "impact";
			}
			.menuText{
				font-size: 150%;
				font-family: "courier";
				margin-right: 
			}
			.menuText p{
				padding-bottom: 20px;
				width: 75%;
			}
			.menuButton{
				font-size: 200%;
				font-family: "impact";
			}
			.bigMenuButton{
				font-size: 300%;
				font-family: "impact";
			}
			#playButton{
				width: 100px;
       			height: 50px;
			}
		</style>
		<title> Blower Game </title>
		<script
			src="https://code.jquery.com/jquery-3.3.1.js"
			integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
			crossorigin="anonymous">
		</script>
		<script src="levels.js" charset="utf-8"></script>
		<script src="debug.js" charset="utf-8"></script>
		<script>
			/*
				
			*/
			let Rules = {boardSize: 2000}
			let FPS = 60;
			

			let ruleSet = {
				speedMod: 3,
				blowRange: 200,
				blowForce: 100,
				friction: 1,
				minSpeed: 1,
				playerSpeed: 500,
				gameSpeed: 0,
				zOrders: {particle: 0, blower: 1, payload: 2, bullet: 3, mine: 4, destructible: 5, turret: 6, barricade: 7, gate: 8, text: 9}
			}

			let canvasWidth;
			let canvasHeight;

			let LevelList = MakeLevelList();

 			let level;

 			let levelPlan;

 			let debug = new Debug;

			Rules = Object.assign(Rules, ruleSet)


			function degToRad(deg){
				return (deg/180*Math.PI);
			}
			function radToDeg(rad){
				return (rad/Math.PI*180)+180;
			}
			/*
			function normalizeRads(rad){
				while(Math.abs(rad) > Math.PI){
					if(rad > 0){
						rad -= Math.PI*2;
					}else{
						rad += Math.PI*2;
					}
				}
				return rad;
			}
			*/
			function calcDist(x1, y1, x2, y2){
				let dx = (x1-x2);
				let dy = (y1-y2);
				return Math.abs(Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2)))
			}
			function pickRandom(list){
				let seed = Math.floor(Math.random()*list.length);
				return list[seed]
			}
			function calcAngle(x1, y1, x2, y2){
				let dx = (x2-x1);
				let dy = (y2-y1);
				let rad = Math.atan2(dy,dx)
				return rad;
			}
			function isWithinArc(sourceRad, targetRad, arc){
				let a0 = sourceRad;
				let a1 = sourceRad - Math.PI*2;
				let a2 = sourceRad + Math.PI*2;
				let min = targetRad - arc;
				let max = targetRad + arc;

				if(
					(a0 >= min && a0 <= max) ||
					(a1 >= min && a1 <= max) ||
					(a2 >= min && a2 <= max)
				){
					return true;
				}
				return false;
			}
			class Board{
				constructor(size){
					this.size = size;
				}
				pickRandomLocation(){
					return Math.random()*this.size-(this.size/2)
				}
			}
 			class Sim{
 				constructor(board){
 					this.pieceList = [];

 					let newPiece;
					
					this.addPiece = (x, y, type, object) => {
 						if(type == "blower"){
							newPiece = (new Blower(this, board, x, y))
						}
 						if(type == "payload"){
							newPiece = (new Payload(this, board, x, y))
						}
						if(type == "gate"){
							newPiece = (new gate(board, x, y))
						}
						if(type == "mine"){
							newPiece = (new Mine(board, x, y))
						}
						if(type == "barricade"){
							newPiece = (new Barricade(board, x, y))
						}
						if(type == "destructible"){
							newPiece = (new Destructible(board, x, y))
						}
						if(type == "turret"){
							newPiece = (new Turret(this, board, x, y, object.fireDelay, object.bulletSpeed))
						}
						if(type == "bullet"){
							newPiece = (new Bullet(board, x, y, object.xVel, object.yVel))
						}
						if(type == "text"){
							newPiece = (new Text(board, x, y, object.text))
						}
						this.pieceList.push(newPiece)
					}
					this.nowPrior = null;
 					this.board = board;

 					for (let i = 0; i < levelPlan.length; i++) {
 						let object = levelPlan[i];
					
						this.addPiece(object.x, object.y, object.type, object)
					}
 					/*
 					for (let i = 0; i < Rules.blowerCount; i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
					
						this.blowerList.push (new Blower(board, x, y, "AI"));
					}
 					this.blower = this.blowerList[0];
 					this.pieceList = [];
 					for (let i = 0; i < (1); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "payload")
					}
					for (let i = 0; i < (1); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "gate")
					}
					for (let i = 0; i < (Rules.mineDensity*(board.size^2)); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "mine")
					}
					for (let i = 0; i < (Rules.barricadeDensity*(board.size^2)); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "barricade")
					}
					*/
 				}
 				find(type){
 					return this.pieceList.find((piece)=>piece.type == type);
 				}
 				exists(type){
 					return !!this.find(type);
 				}
 				get blower(){
 					return this.find("blower");
 				}
 				get payload(){
 					return this.find("payload");
 				}
 				tick(dt){
					this.pieceList.forEach(piece => piece.tick(dt))
					for (var i = 0; i < this.pieceList.length; i++){
						if(this.pieceList[i].dead){
							this.pieceList.splice(i, 1)
						}
					}
				}
 				piecesBlown(dt){
 					let blower = this.blower;
 					if(!blower){return}
					if(blower.blowing){
						for(let i = 0; i < this.pieceList.length; i++){
							let piece = this.pieceList[i];
							if(!piece.blowable){
								continue;
							}
							let angle = calcAngle(blower.x, blower.y, piece.x, piece.y);
							let blowArc = degToRad(45);
							let dist = calcDist(blower.x, blower.y, piece.x, piece.y);
							if(isWithinArc(blower.angle, angle, blowArc) && dist < Rules.blowRange){
								let velIncrease = (((Rules.blowRange-calcDist(blower.x, blower.y, piece.x, piece.y))*Rules.blowForce)/piece.mass)*dt;
								piece.xVel -= velIncrease*((blower.x - piece.x)/dist)
								piece.yVel -= velIncrease*((blower.y - piece.y)/dist)
							}
						}
					}else{
						console.log()
					}
				}
 				piecesTouched(){
 					let nextLevel = false;
					this.pieceList.forEach(piece => {
						if(piece.dead || !piece.collider){
							return;
						}
						for(let i = 0; i < this.pieceList.length; i++){
							let piece2 = this.pieceList[i];
							if(piece2.dead || !piece2.collider){
								continue;
							}
							if(piece == piece2){
								continue;
							}
							if(calcDist(piece.x, piece.y, piece2.x, piece2.y) < (piece.hitBoxRadius+piece2.hitBoxRadius)){
								if(piece.onTouch(piece2.effect) == "next level"){
									nextLevel = true;
								}
							}
						}
					})
					if(nextLevel){
						return "next level"
					}
				}
			}

			class Piece{
				constructor(type, board, x, y, isParticle){
					debug.expect(board, "object", "board")
					debug.expectNum(x, "x")
					debug.expectNum(y, "y")
					this.board = board;
					this.type = type;
					this.x = x;
					this.y = y;
					let z;
					if(isParticle){
						z = Rules.zOrders.particle;
					}else{
						z = Rules.zOrders[this.type];
					}
					debug.expectNum(z, "z")
					this.z = z+Math.random();
					this.xVel = 0;
					this.yVel = 0;
					this.mass = 1;
					this.width;
					this.height;
					this.hitBoxRadius;
					this.effect;
					this.collider = true;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.draw(pieceSpec, Img[this.type], camera)
				}
				onTouch(effect){
					if(effect.type == "damage"){
						this.health -= effect.amount;
					}
					if(effect.type == "win" && this.type == "gate"){
						this.health = 0;
						return "next level";
					}
				}
				applyVelocity(dt){
					let velocity = Math.sqrt(this.xVel*this.xVel+this.yVel*this.yVel);
					if( velocity > Rules.minSpeed ) {
						this.x += this.xVel*dt*Rules.gameSpeed;
						this.y += this.yVel*dt*Rules.gameSpeed;
					}
				}
				applyFriction(dt){
					this.xVel -= (this.xVel*Rules.friction)*dt*Rules.gameSpeed;
					this.yVel -= (this.yVel*Rules.friction)*dt*Rules.gameSpeed;

					//if(Math.sqrt(this.xVel*this.xVel+this.yVel*this.yVel) < Rules.minSpeed){
					//	this.xVel = 0;
					//	this.yVel = 0;
					//}
				}
				particleTick(){}
				tick(dt){
					this.particleTick(dt);
					if(!this.dead){
						if(this.control == "AI"){
							//this.ai(pieceList);
						}
						this.applyVelocity(dt)

						this.applyFriction(dt)

						if(this.x > this.board.size/2){
							this.dead = true;
						}
						if(this.x < -this.board.size/2){
							this.dead = true;
						}
						if(this.y > this.board.size/2){
							this.dead = true;
						}
						if(this.y < -this.board.size/2){
							this.dead = true;
						}
						if(this.health < 1){
							this.dead = true;
							if(this.type == "payload"){
								MakeParticle(this.sim, "explosion", this.x, this.y, this.xVel/3, this.yVel/3, 0)	
							}
						}
					}
				}
			}

			class Payload extends Piece{
				constructor(sim, board, x, y){
					super("payload", board, x, y)
					this.mass = 25;
					this.width = 40;
					this.height = 40;
					this.sim = sim;
					this.hitBoxRadius = 20;
					this.blowable = true;
					this.effect = {type: "win", amount: 10};
					this.health = 10;
				}
				particleTick(dt){
					for (var i = 0; i < dt*10; i++) {
						if(Math.random()>0.95){
							MakeParticle(this.sim, "electricity", this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*10), 0, 0, 0)
						}
					}
				}
			}

			class gate extends Piece{
				constructor(board, x, y){
					super("gate", board, x, y)
					this.width = 150;
					this.height = 150;
					this.hitBoxRadius = 7.5;
					this.blowable = false;
					this.effect = {type: "none"};
				}
				/*particleTick(dt){
					let particleAngleMargin = degToRad(90)
					let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
					let velocity = 750;
					let xVel = velocity*Math.cos(particleAngle);
					let yVel = velocity*Math.sin(particleAngle);
					MakeParticle(this.sim, "force", this.x, this.y, xVel, yVel, radToDeg(particleAngle)+180)
				}*/
			}

 			class Mine extends Piece{
				constructor(board, x, y){
					super("mine", board, x, y)
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.hitBoxRadius = 15;
					this.blowable = true;
					this.effect = {type: "damage", amount: 10};
				}
			}

			class Barricade extends Piece{
				constructor(board, x, y){
					super("barricade", board, x, y)
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 45;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Destructible extends Piece{
				constructor(board, x, y){
					super("destructible", board, x, y)
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.health = 1;
					this.collider = true;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Turret extends Piece{
				constructor(sim, board, x, y, fireDelay, bulletSpeed){
					super("turret",board, x, y)
					debug.expectNum(fireDelay, "fireDelay")
					debug.expectNum(bulletSpeed, "bulletSpeed")
					this.sim = sim;
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 50;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
					this.fireDelay = fireDelay;
					this.timeToNextFire = this.fireDelay;
					this.bulletSpeed = bulletSpeed;
					this.angle = 0;
				}
				tick(dt){
					this.particleTick(dt);
					let target = this.sim.payload;
					if(target){
						this.angle = calcAngle(this.x, this.y, target.x, target.y);
					}

					if(this.timeToNextFire <= 0){
						this.timeToNextFire = this.fireDelay;
						let velocity = this.bulletSpeed;
						let xVel = velocity*Math.cos(this.angle);
						let yVel = velocity*Math.sin(this.angle);
						this.sim.addPiece(this.x, this.y, "bullet", {type: "bullet", x: this.x, y: this.y, xVel: xVel, yVel: yVel})
					}else{
						this.timeToNextFire -= dt*Rules.gameSpeed;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.drawRotated(pieceSpec, Img.turret, camera, radToDeg(this.angle))
				}
			}
			class Bullet extends Piece{
				constructor(board, x, y, xVel, yVel){
					super("bullet", board, x, y)
					debug.expectNum(xVel, "xVel")
					debug.expectNum(yVel, "yVel")
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.xVel = xVel;
					this.yVel = yVel;
					this.hitBoxRadius = 15;
					this.blowable = true;
					this.effect = {type: "damage", amount: 10};
				}
				tick(dt){
					this.particleTick(dt);

					this.applyVelocity(dt)

					if(this.x > this.board.size/2){
						this.dead = true;
					}
					if(this.x < -this.board.size/2){
						this.dead = true;
					}
					if(this.y > this.board.size/2){
						this.dead = true;
					}
					if(this.y < -this.board.size/2){
						this.dead = true;
					}
				}
			}
			class Text extends Piece{
				constructor(board, x, y, text){
					super("text", board, x, y)
					debug.expect(text, "string", "text")
					this.hitBoxRadius = 0;
					this.text = text;
					this.blowable = false;
					this.effect = {type: "none"};
				}
				draw(context, camera){
					let drawX = this.x-(camera.x-canvasWidth/2);
					let drawY = this.y-(camera.y-canvasHeight/2);
					context.font = "30px Arial";
					context.fillStyle = 'white';
					context.fillText(this.text, drawX, drawY);
				}
			}

 			class Blower extends Piece{
				constructor(sim, board, x, y, control){
					super("blower", board, x, y, 1)
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.blowable = false;
					this.effect = {type: "none"};
					this.collider = false;

					this.sim = sim;
					this.board = board;
					this.control = control;
					this.angle = (Math.random()*Math.PI*2)-Math.PI;
					this.speed = Rules.playerSpeed;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					let angle = (this.angle/Math.PI)*180
					context.drawRotated(pieceSpec, Img.blower, camera, angle)
				}
				moveTick(dt){
					if(wDown){
						this.y -= this.speed*dt*Rules.gameSpeed;
					}
					if(sDown){
						this.y += this.speed*dt*Rules.gameSpeed;
					}
					if(aDown){
						this.x -= this.speed*dt*Rules.gameSpeed;
					}
					if(dDown){
						this.x += this.speed*dt*Rules.gameSpeed;
					}
				}
				particleTick(dt){
					MakeParticle(this.sim, "trail", this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*10), 0, 0, 0)
					if(this.blowing){
						for (var i = 0; i < 100*dt*Rules.gameSpeed; i++) {
							let particleAngleMargin = degToRad(90)
							let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
							let velocity = 750;
							let xVel = velocity*Math.cos(particleAngle);
							let yVel = velocity*Math.sin(particleAngle);
							MakeParticle(this.sim, "force", this.x, this.y, xVel, yVel, radToDeg(particleAngle)+180, this)
						}
					}
				}
				ai(pieceList){
					let directionList = ["up", "down", "left", "right"]
					//if(Math.random() > 0.999){
					//	this.direction = directionList[Math.floor(Math.random()*4)]
					//}
					
				}
				tick(dt){
					this.moveTick(dt);
					this.particleTick(dt)
					if(this.health <= 0 ){
						this.dead = true;
					}
				}
				grow(amount){
					this.length += amount*Rules.growSpeedMod*(this.speed+this.tempSpeed)/100;
				}
				speedBoost(amount){
					this.tempSpeed += amount*Rules.speedBoostMod;
				}
				strengthen(amount){
					this.strength += amount*Rules.strengthAddMod;
				}
				setTarget(x, y){
					this.angle = calcAngle(this.x, this.y, x, y);
				}
			}

			class Particle extends Piece{
				constructor(type, board, x, y, xVel, yVel, angle, parent){
					super(type, board, x, y, true)
					this.width = 5;
					this.height = 5;
					this.xVel = xVel;
					this.yVel = yVel;
					this.blowable = false;
					this.collider = false;
					this.lifeRemaining = Rules.blowRange/(xVel+yVel);
					this.angle = angle;
					if( parent ) {
						this.parent = parent;
						this.px = this.parent.x;
						this.py = this.parent.y;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					if(this.angle == 0){
						context.draw(pieceSpec, Img[this.type], camera)
					}else{
						context.drawRotated(pieceSpec, Img[this.type], camera, this.angle)
					}
				}
				tick(dt){
					if(!this.dead){
						if( this.parent ) {
							let pdx = this.parent.x - this.px;
							let pdy = this.parent.y - this.py;
							this.x += pdx;
							this.y += pdy;
							this.px = this.parent.x;
							this.py = this.parent.y;
						}

						this.applyVelocity(dt)

						this.lifeRemaining -= dt*Rules.gameSpeed;
						if(this.lifeRemaining <= 0){
							this.dead = true;
						}
					}
				}
			}
			class Force extends Particle{
				constructor(board, x, y, xVel, yVel, angle, parent){
					super("force", board, x, y, xVel, yVel, angle, parent)
					this.width = 40;
					this.height = 10;
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Trail extends Particle{
				constructor(board, x, y, xVel, yVel){
					super("trail", board, x, y, xVel, yVel)
					this.width = 5;
					this.height = 5;
					this.angle = Math.random()*360;
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Electricity extends Particle{
				constructor(board, x, y, xVel, yVel){
					super("electricity", board, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.lifeRemaining = Math.random()*0.2;
				}
			}
			class PortalEnergy extends Particle{
				constructor(board, x, y, xVel, yVel){
					super("portalEnergy", board, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.lifeRemaining = 0.5;
				}
			}
			class Explosion extends Particle{
				constructor(board, x, y, xVel, yVel){
					super("explosion", board, x, y, xVel, yVel)
					this.width = 200;
					this.height = 200;
					this.angle = 0;
					this.totalLife = 0.52;
					this.lifeRemaining = this.totalLife;
				}
				draw(context, camera){
					let frameCount = 13;
					let frame = Math.floor(((this.totalLife-this.lifeRemaining)/this.totalLife)*frameCount) //12 frames in the explosion image.
					let frameWidth = 2548/frameCount;
					let frameHeight = 190;

					let pieceSpec = {
						sx: frame*frameWidth,
						sy: 0,
						sw: frameWidth,
						sh: frameHeight,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};

					context.draw(pieceSpec, Img[this.type], camera)
				}
			}
			function MakeParticle(sim, type, x, y, xVel, yVel, angle, parent){
				if(type == "force"){
					sim.pieceList.push(new Force(sim.board, x, y, xVel, yVel, angle, parent))
				}
				if(type == "trail"){
					sim.pieceList.push(new Trail(sim.board, x, y, xVel, yVel))
				}
				if(type == "electricity"){
					sim.pieceList.push(new Electricity(sim.board, x, y, xVel, yVel))
				}
				if(type == "portalEnergy"){
					sim.pieceList.push(new PortalEnergy(sim.board, x, y, xVel, yVel))
				}
				if(type == "explosion"){
					sim.pieceList.push(new Explosion(sim.board, x, y, xVel, yVel))
				}
			}
 			//CONTROL
 			let wDown;
 			let sDown;
			let aDown;
			let dDown;
			function initControls(sim){
				let blower = sim.pieceList[0];
				let mouseX = 0;
				let mouseY = 0;
				$( document ).on("mousemove.controls", null, function( event ) {
					mouseX = event.pageX+blower.x-canvasWidth/2;
					mouseY = event.pageY+blower.y-canvasHeight/2;
					blower.setTarget(mouseX, mouseY)
				});
				$( document ).on("mousedown.controls", null,function( event ) {
					blower.blowing = true;
				});
				$( document ).on("mouseup.controls", null, function( event ) {
					blower.blowing = false;
				});
				$( document ).on("keydown.controls", null, function( event ) {
					if(event.key == "w" || event.key == "W"){
						wDown = true;
					}
					if(event.key == "s" || event.key == "S"){
						sDown = true;
					}
					if(event.key == "a" || event.key == "A"){
						aDown = true;
					}
					if(event.key == "d" || event.key == "D"){
						dDown = true;
					}
					if(event.key == "Escape"){
						if(Rules.gameSpeed){
							PauseGame(handleView)
							console.log("pause")
						}else{
							UnpauseGame()
							console.log("unpause")
						}
					}
					if(level == 0){
						if(event.key == "0"){
							EditLevel(sim, levelPlan, "deletePiece")
						}
						if(event.key == "1"){
							EditLevel(sim, levelPlan, "blower", mouseX, mouseY)
						}
						if(event.key == "2"){
							EditLevel(sim, levelPlan, "gate", mouseX, mouseY)
						}
						if(event.key == "3"){
							EditLevel(sim, levelPlan, "payload", mouseX, mouseY)
						}
						if(event.key == "4"){
							EditLevel(sim, levelPlan, "barricade", mouseX, mouseY)
						}
						if(event.key == "5"){
							EditLevel(sim, levelPlan, "mine", mouseX, mouseY)
						}
						if(event.key == "6"){
							EditLevel(sim, levelPlan, "destructible", mouseX, mouseY)
						}
						if(event.key == "7"){
							EditLevel(sim, levelPlan, "turret", mouseX, mouseY)
						}
					}
				});
				$( document ).on("keyup.controls", null, function( event ) {
					if(event.key == "w" || event.key == "W"){
						wDown = false;
					}
					if(event.key == "s" || event.key == "S"){
						sDown = false;
					}
					if(event.key == "a" || event.key == "A"){
						aDown = false;
					}
					if(event.key == "d" || event.key == "D"){
						dDown = false;
					}
					
				});

			}
 			//VIEW
 			let ImageURLs = {
				blower: 'images/mover2.png',
				payload: 'images/payload.png',
				gate: 'images/gate.png',
				mine: 'images/mine.png',
				barricade: 'images/barricade.png',
				destructible: 'images/destructible.png',
				turret: 'images/turret.png',
				bullet: 'images/bullet.png',
				//wind: 'images/wind2.png',
				background: 'images/black.png',
				force: 'images/particles/force2.png',
				trail: 'images/particles/trail.png',
				electricity: 'images/particles/lightning.png',
				portalEnergy: 'images/particles/trail.png',
				explosion: 'images/explosion.png',
				//minimapBackground: 'images/minimapBackground.jpg',
			};
 			let Img = {};
 			class View{
				constructor(){
 				}
				
 				imageLoad(imageURLs, target, callbackFn){
					let imagesRequested = 0;
					let imagesLoaded = 0;
					for(let key in imageURLs){
						let image = imageURLs[key];
						target[key] = new Image();
						target[key].onload = function(){
							imagesLoaded ++
						};
						target[key].src = image;
						imagesRequested ++;
					}
 					let handle = setInterval( () => {
						if( imagesLoaded >= imagesRequested ) {
							console.assert(imagesLoaded == imagesRequested)
							clearInterval(handle);
							displayTitleScreen();
						}
					},1)
				}
 				myCanvas(canvasId, board){
					var canvas = document.getElementById(canvasId);
					var context = canvas.getContext('2d');
					context.canvas.width = window.innerWidth;
					context.canvas.height = window.innerHeight;
					
					context.draw = function(spec, imageObj, camera){
						let drawX = spec.x-(camera.x-canvasWidth/2);
						let drawY = spec.y-(camera.y-canvasHeight/2);
						if(spec.xAnchor && spec.yAnchor){
							drawX -= spec.width*spec.xAnchor;
							drawY -= spec.height*spec.yAnchor;
						}
						if(spec.sx !== undefined){
							this.drawImage(imageObj, spec.sx, spec.sy, spec.sw, spec.sh, drawX, drawY, spec.width, spec.height);
						}else{
							this.drawImage(imageObj, drawX, drawY, spec.width, spec.height);
						}
					}.bind(context)
					context.clear = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, canvas.width, canvas.height);
					}.bind(context)
					/*context.clearMinimap = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, 280, 260);
					}.bind(context)*/
					context.drawRotated = function(spec, imageObj, camera, degrees){
						let x = spec.x-(camera.x-canvasWidth/2);
						let y = spec.y-(camera.y-canvasHeight/2);
						x -= spec.width*spec.xAnchor;
						y -= spec.height*spec.yAnchor;
						
						let w = spec.width;
						let h = spec.height;

						this.save();
						this.translate(x+w/2, y+h/2);
						this.rotate(degrees*Math.PI/180.0);
						this.translate(-x-w/2, -y-h/2);
						this.drawImage(imageObj, x, y, w, h);
						this.restore();
					}.bind(context)
					return context
				}
 				render(context, sim){
					context.clear();
 					let camera = {};
 					camera.x = sim.blower.x;
					camera.y = sim.blower.y;
					sim.pieceList.sort(function(a, b){return b.z - a.z});
 					for(let i = 0; i < sim.pieceList.length; i++){
						
						if(!sim.pieceList[i].dead){
							sim.pieceList[i].draw(context, camera)
						}
					}
				}
/*				renderMinimap(context, sim){
					context.clearMinimap()
					
					let camera = {};
 					camera.x = 100;
					camera.y = 100;

					let boardSizeMod = (sim.board.size/2000)

 					for(let i = 0; i < sim.pieceList.length; i++){
						let pieceSpec = {x: sim.pieceList[i].x/10, y: sim.pieceList[i].y/10, width: (sim.pieceList[i].width/10)/boardSizeMod, height: (sim.pieceList[i].height/10)/boardSizeMod, xAnchor: 0.5, yAnchor: 0.5};
						
						let drawX = (pieceSpec.x+(120*boardSizeMod))/boardSizeMod;
						let drawY = (pieceSpec.y+(130*boardSizeMod))/boardSizeMod;
						
						if(pieceSpec.xAnchor && pieceSpec.yAnchor){
							drawX -= pieceSpec.width*pieceSpec.xAnchor;
							drawY -= pieceSpec.height*pieceSpec.yAnchor;
						}

						if(!sim.pieceList[i].dead){
							context.drawImage(Img[sim.pieceList[i].type], drawX, drawY, pieceSpec.width, pieceSpec.height);
						}
					}

					let blowerSpec = {x: sim.pieceList[0].x/10, y: sim.pieceList[0].y/10, width: 10, height: 10, xAnchor: 0.5, yAnchor: 0.5};

					let drawX = (blowerSpec.x+(120*boardSizeMod))/boardSizeMod;
					let drawY = (blowerSpec.y+(130*boardSizeMod))/boardSizeMod;
					
					if(blowerSpec.xAnchor && blowerSpec.yAnchor){
						drawX -= blowerSpec.width*blowerSpec.xAnchor;
						drawY -= blowerSpec.height*blowerSpec.yAnchor;
					}
					context.drawImage(Img.blower, drawX, drawY, blowerSpec.width, blowerSpec.height);
					
				}*/
			}
 			//ORGANIZATION
			function displayTitleScreen(){
				$("#canvas").hide()
				$("#brief").hide()
				$("#gameOverScreen").hide()
				$("#levelSelect").hide()
				$("#titleScreen").show()
			}
			function displayLevelSelect(){
				$("#gameOverScreen").hide()
				$("#titleScreen").hide()
				$("#levelSelect").show()
				$("#levelSelect").html('');
				for (let i = 1; i < LevelList.length; i++) {
					$("#levelSelect").append('<button class="menuButton" onClick="level = '+i+'; levelPlan = LevelList[level]; Main()">'+i+'</button>');
				}
				$("#levelSelect").prepend('<h1 class="menuTitle">Choose A Level</h1>')
				$("#levelSelect").append('<br> </br> <button class="menuButton" onClick="level = 0; levelPlan = LevelList[0]; Main()">Level Builder</button> <br> </br> <button class="menuButton" onClick="displayTitleScreen()">Back</button>');
			}
			function displayGameOverScreen(win){
				$("#canvas").hide()
				$("#levelSelect").hide()
				$("#menus").show()
				$("#gameOverScreen").show()
				if(win){
					$("#gameOverScreen").html('<h1 class="menuTitle">You Win!</h1> <button class="menuButton" onClick="displayLevelSelect()">Main Menu</button> <button class="menuButton" onClick="level = '+level+'; levelPlan = LevelList[level]; Main()">Play Again</button> <button class="menuButton" onClick="level = '+(level+1)+'; levelPlan = LevelList[level]; Main()">Next Level</button>');
				}else{
					$("#gameOverScreen").html('<h1 class="menuTitle">You Lose!</h1> <button class="menuButton" onClick="displayLevelSelect()">Main Menu</button> <button class="menuButton" onClick="level = '+level+'; levelPlan = LevelList[level]; Main()">Try Again</button>');
				}
			}
			function displayBrief(){
				$("#titleScreen").hide()
				$("#brief").show()
			}
 			function GameOver(handleView){
 				$(document).off(".controls")
 				cancelAnimationFrame(handleView)
			}
			function PauseGame(){
				Rules.gameSpeed = 0;
				$("#restartLevelButton").click(
					()=>{
						GameOver(handleView);
						levelPlan = LevelList[level];
						Main();
					}
				)
				$("#pauseMenuOuter").show()
			}
			function UnpauseGame(){
				Rules.gameSpeed = 0.5;
				$("#pauseMenuOuter").hide()
			}

			let handleView;
 			function Main(){
 				UnpauseGame()
 				//level = prompt("Which level would you like to play?");
				wDown = false;
				sDown = false;
				aDown = false;
				dDown = false;

				$("#menus").hide()
				$("#canvas").show()
				let view = new View();
				let board = new Board(Rules.boardSize);
				let context = view.myCanvas('canvas', board);
				let sim = new Sim(board);
				initControls(sim);
				let levelPlan = LevelList[level]
				
				function tickSim(){
					let levelPlan = LevelList[level]
					if(!sim.payload){
						setTimeout(() => {
							GameOver(handleView)
							displayGameOverScreen(false)
						},1000)
					}

					sim.timeSinceLastSim = 0;
					let dt;
					let now = Date.now();
					if(sim.nowPrior === null){
						dt = 1.0/FPS;
					}else{
						dt = (now - sim.nowPrior)/1000;
					}
					sim.nowPrior = now;
					sim.timeSinceLastSim += dt;
					while(sim.timeSinceLastSim > 1/FPS){
						sim.piecesBlown(dt);
						if(sim.piecesTouched() == "next level"){
							return "next level"
						}
						sim.tick(1/FPS);
						sim.timeSinceLastSim -= 1/FPS;
					}
				}
 				function tickView(){
					view.render(context, sim);
					//view.renderMinimap(context, sim);
				}

				$("#titleScreen").hide()

				function animateView(){
					tickView()
					handleView = requestAnimationFrame( animateView );
					if(tickSim() == "next level"){
						GameOver(handleView)
						displayGameOverScreen(true)
					}
				}
 				animateView();
			}
			$(document).ready(function(){
 				$("#titleScreen").hide() //temporary for dev
 				
 				canvasWidth = $("#canvas").width();
				canvasHeight = $("#canvas").height();
				console.assert(canvasWidth > 0)
				console.assert(canvasHeight > 0)

				let view = new View();
				view.imageLoad(ImageURLs, Img, Main);
				
				$(window).resize(function(){
					let canvasId = "canvas"
					let canvas = document.getElementById(canvasId);
					let context = canvas.getContext('2d');
					context.canvas.width = window.innerWidth;
					context.canvas.height = window.innerHeight;
	 				canvasWidth = $("#canvas").width();
					canvasHeight = $("#canvas").height();
				})
			});
			
			//art by: eleksey goldis
    </script>
  </body>
</html>        
		</script>
	</head>
	<body>
		<div id="menus">
			<div id="titleScreen" class="menu">
				<h1 class="menuTitle">
					Blower Game
				</h1>
				<button class="bigMenuButton" onClick="level = 1; levelPlan = LevelList[level]; Main()">
					Play
				</button>
				<br>
				<button class="menuButton" onClick="displayBrief()">
					Briefing
				</button>
				<button class="menuButton" onClick="displayLevelSelect()">
					Level Select
				</button>
			</div>
			<div id="brief" class="menu">
				<h1 class="menuTitle">
					Your Mission
				</h1>
				<div class="menuText">
					<p>
						The enemy has stolen the Quantum Arc-Reactor and placed it deep behind enemy lines.
						You must get it back to High Command.
					</p>
					<p>
						We can warp you to the Arc-Reactor.
						Use your repulser to push it through the blue warp gates. They will lead you back to High Command.
					</p>
					<p>
						However, the Arc-Reactor is unstable!
						If it touches anything, it will go critical and our most valuable asset will be destroyed.
						This is why you must get it back to us with only your repulser field.
					</p>
					<p>
						Good Luck, Captain.
					</p>
				</div>
				<button class="menuButton" onClick="displayTitleScreen()">
					Understood
				</button>
			</div>
			<div id="levelSelect" class="menu">
				<h1 class="menuTitle">
					Choose A Level
				</h1>
			</div>
			<div id="gameOverScreen" class="menu">
			</div>
		</div>
		<div id="canvasDiv" width="100%" height="100%">
			<div id="pauseMenuOuter">
				<div id="pauseMenu">
					<h1 class="menuTitle">
						Game Paused
					</h1>
					<button class="menuButton" onclick="UnpauseGame()">
						Resume Game
					</button>
					<button class="menuButton" id="restartLevelButton">
						Restart Level
					</button>
					<button class="menuButton" onclick="GameOver(false)">
						Main Menu
					</button>
				</div>
			</div>
			<canvas id="canvas" width="100%" height="100%"></canvas>
		</div>
	</body>
</html>