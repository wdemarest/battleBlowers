<html>
	<head>
		<link rel="stylesheet" type="text/css" href="minireset.css">
		<style type="text/css">
			html, body{
				height: 100%;
			}
			#canvas{
				width: 100%;
				height: 120%;
				cursor: crosshair;
			}
			#menus{
				border: 1px solid black;
				height: 100%;
				background-size: cover;
				background-repeat: no-repeat;
				background-image: url('images/monitor.jpg');
			}
			.menu{
				margin-left: 15%;
				margin-top: 6%;
			}
			.mainTitle{
				font-size: 500%;
				font-family: "impact";
			}
			.menuTitle{
				font-size: 500%;
				font-family: "impact";
			}
			.menuText{
				font-size: 150%;
				font-family: "courier";
			}
			.menuButton{
				font-size: 300%;
				font-family: "impact";
			}
			#playButton{
				width: 100px;
       			height: 50px;
			}
		</style>
		<title> Blower Game </title>
		<script
  src="https://code.jquery.com/jquery-3.3.1.js"
  integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
  crossorigin="anonymous"></script>
  <script src="levels.js" charset="utf-8"></script>
		<script>
			/*
				
			*/
			let Rules = {boardSize: 2000}
			let FPS = 60;
			

			let ruleSet = {
				speedMod: 3,
				blowRange: 200,
				blowForce: 100,
				friction: 0.1
			}

			let canvasWidth;
			let canvasHeight;

			let LevelList = MakeLevelList();

 			let level;

 			let levelPlan;

			Rules = Object.assign(Rules, ruleSet)


			function degToRad(deg){
				return (deg/180*Math.PI);
			}
			function radToDeg(rad){
				return (rad/Math.PI*180)+180;
			}
			/*
			function normalizeRads(rad){
				while(Math.abs(rad) > Math.PI){
					if(rad > 0){
						rad -= Math.PI*2;
					}else{
						rad += Math.PI*2;
					}
				}
				return rad;
			}
			*/
			function calcDist(x1, y1, x2, y2){
				let dx = (x1-x2);
				let dy = (y1-y2);
				return Math.abs(Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2)))
			}
			function pickRandom(list){
				let seed = Math.floor(Math.random()*list.length);
				return list[seed]
			}
			function calcAngle(x1, y1, x2, y2){
				let dx = (x2-x1);
				let dy = (y2-y1);
				let rad = Math.atan2(dy,dx)
				return rad;
			}
			class Board{
				constructor(size){
					this.size = size;
				}
				pickRandomLocation(){
					return Math.random()*this.size-(this.size/2)
				}
			}
 			class Sim{
 				constructor(board){
 					this.pieceList = [];
					
					this.addPiece = (x, y, type, var1, var2, var3) => {
 						if(type == "blower"){
							return this.pieceList.push(new Blower(this, board, x, y))
						}
 						if(type == "payload"){
							return this.pieceList.push(new Payload(this, board, x, y))
						}
						if(type == "destination"){
							return this.pieceList.push(new Destination(board, x, y))
						}
						if(type == "bomb"){
							return this.pieceList.push(new Bomb(board, x, y))
						}
						if(type == "block"){
							return this.pieceList.push(new Block(board, x, y))
						}
						if(type == "destructible"){
							return this.pieceList.push(new Destructible(board, x, y))
						}
						if(type == "turret"){
							return this.pieceList.push(new Turret(this, board, x, y, var1, var2))
						}
						if(type == "bullet"){
							return this.pieceList.push(new Bullet(board, x, y, var1, var2))
						}
						if(type == "text"){
							return this.pieceList.push(new Text(board, x, y, var1))
						}
					}
					this.nowPrior = null;
 					this.board = board;

 					for (let i = 0; i < levelPlan.length; i++) {
 						let object = levelPlan[i];
					
						this.addPiece(object.x, object.y, object.type, object.var1, object.var2, object.var3)
					}

					this.blower = this.pieceList[0];

 					/*
 					for (let i = 0; i < Rules.blowerCount; i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
					
						this.blowerList.push (new Blower(board, x, y, "AI"));
					}
 					this.blower = this.blowerList[0];
 					this.pieceList = [];
 					for (let i = 0; i < (1); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "payload")
					}
					for (let i = 0; i < (1); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "destination")
					}
					for (let i = 0; i < (Rules.bombDensity*(board.size^2)); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "bomb")
					}
					for (let i = 0; i < (Rules.blockDensity*(board.size^2)); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "block")
					}
					*/
 				}
 				tick(dt){
					this.pieceList.forEach(piece => piece.tick(dt))
					for (var i = 0; i < this.pieceList.length; i++){
						if(this.pieceList[i].dead){
							this.pieceList.splice(i, 1)
						}
					}
				}
 				piecesBlown(dt){
					if(this.pieceList[0].blowing){
						let blower = this.pieceList[0];
						for(let i = 0; i < this.pieceList.length; i++){
							let piece = this.pieceList[i];
							if(!piece.blowAble){
								continue;
							}
							let angle = calcAngle(blower.x, blower.y, piece.x, piece.y);
							let blowArc = degToRad(45);
							let dist = calcDist(blower.x, blower.y, piece.x, piece.y);
							if(blower.angle < angle+blowArc && blower.angle > angle-blowArc && dist < Rules.blowRange){
								let velIncrease = (((Rules.blowRange-calcDist(blower.x, blower.y, piece.x, piece.y))*Rules.blowForce)/piece.mass)*dt;
								piece.xVel -= velIncrease*((blower.x - piece.x)/dist)
								piece.yVel -= velIncrease*((blower.y - piece.y)/dist)
								piece.lit = true;
							}else{
								piece.lit = false;
							}
						}
					}
				}
 				piecesTouched(){
 					let nextLevel = false;
					this.pieceList.forEach(piece => {
						if(piece.dead || !piece.collider){
							return;
						}
						for(let i = 0; i < this.pieceList.length; i++){
							let piece2 = this.pieceList[i];
							if(piece2.dead || !piece2.collider){
								continue;
							}
							if(piece == piece2){
								continue;
							}
							if(calcDist(piece.x, piece.y, piece2.x, piece2.y) < (piece.hitBoxRadius+piece2.hitBoxRadius)){
								if(piece.onTouch(piece2.effect) == "next level"){
									nextLevel = true;
								}
							}
						}
					})
					if(nextLevel){
						return "next level"
					}
				}
			}

			class Piece{
				constructor(board, x, y){
					this.board = board;
					this.x = x;
					this.y = y;
					this.xVel = 0;
					this.yVel = 0;
					this.type;
					this.mass = 1;
					this.width;
					this.height;
					this.hitBoxRadius;
					this.effect;
					this.collider = true;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.draw(pieceSpec, Img[this.type], camera)
				}
				onTouch(effect){
					if(effect.type == "damage"){
						this.health -= effect.amount;
					}
					if(effect.type == "win" && this.type == "destination"){
						this.health = 0;
						return "next level";
					}
				}
				particleTick(){}
				tick(dt){
					this.particleTick(dt);
					if(!this.dead){
						if(this.control == "AI"){
							//this.ai(pieceList);
						}
						this.x += this.xVel*dt;
						this.y += this.yVel*dt;

						this.xVel -= (this.xVel*Rules.friction)*dt;
						this.yVel -= (this.yVel*Rules.friction)*dt;

						if(this.x > this.board.size/2){
							this.dead = true;
						}
						if(this.x < -this.board.size/2){
							this.dead = true;
						}
						if(this.y > this.board.size/2){
							this.dead = true;
						}
						if(this.y < -this.board.size/2){
							this.dead = true;
						}
						if(this.health < 1){
							this.dead = true;
							if(this.type == "payload"){
								MakeParticle(this.sim, "explosion", this.x, this.y, this.xVel/3, this.yVel/3, 0)	
							}
						}
					}
				}
			}

			class Payload extends Piece{
				constructor(sim, board, x, y){
					super(board, x, y)
					this.type = "payload";
					this.mass = 25;
					this.width = 40;
					this.height = 40;
					this.sim = sim;
					this.hitBoxRadius = 20;
					this.blowAble = true;
					this.effect = {type: "win", amount: 10};
					this.health = 10;
				}
				particleTick(dt){
					for (var i = 0; i < dt*10; i++) {
						if(Math.random()>0.95){
							MakeParticle(this.sim, "electricity", this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*10), 0, 0, 0)
						}
					}
				}
			}

			class Destination extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "destination";
					this.width = 150;
					this.height = 150;
					this.hitBoxRadius = 5;
					this.blowAble = false;
					this.effect = {type: "none"};
				}
				/*particleTick(dt){
					let particleAngleMargin = degToRad(90)
					let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
					let velocity = 750;
					let xVel = velocity*Math.cos(particleAngle);
					let yVel = velocity*Math.sin(particleAngle);
					MakeParticle(this.sim, "force", this.x, this.y, xVel, yVel, radToDeg(particleAngle)+180)
				}*/
			}

 			class Bomb extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "bomb";
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.hitBoxRadius = 15;
					this.blowAble = true;
					this.effect = {type: "damage", amount: 10};
				}
			}

			class Block extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "block";
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 50;
					this.blowAble = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Destructible extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "destructible";
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.health = 1;
					this.collider = true;
					this.blowAble = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Turret extends Piece{
				constructor(sim, board, x, y, fireDelay, bulletSpeed){
					super(board, x, y)
					this.type = "turret";
					this.sim = sim;
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 50;
					this.blowAble = false;
					this.effect = {type: "damage", amount: 10};
					this.fireDelay = fireDelay;
					this.timeToNextFire = this.fireDelay;
					this.bulletSpeed = bulletSpeed;
					this.angle = 0;
				}
				tick(dt){
					this.particleTick(dt);
					if(this.control == "AI"){
						//this.ai(pieceList);
					}

					if(this.timeToNextFire <= 0){
						this.timeToNextFire = this.fireDelay;
						let velocity = this.bulletSpeed;
						let xVel = velocity*Math.cos(this.angle);
						let yVel = velocity*Math.sin(this.angle);
						this.sim.addPiece(this.x, this.y, "bullet", xVel, yVel)
					}else{
						this.timeToNextFire -= dt;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					let target = this.sim.pieceList[2]
					this.angle = calcAngle(this.x, this.y, target.x, target.y);
					context.drawRotated(pieceSpec, Img.turret, camera, radToDeg(this.angle))
				}
			}
			class Bullet extends Piece{
				constructor(board, x, y, xVel, yVel){
					super(board, x, y)
					this.type = "bullet";
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.xVel = xVel;
					this.yVel = yVel;
					this.hitBoxRadius = 15;
					this.blowAble = true;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Text extends Piece{
				constructor(board, x, y, text){
					super(board, x, y)
					this.type = "text";
					this.hitBoxRadius = 0;
					this.text = text;
					this.blowAble = false;
					this.effect = {type: "none"};
				}
				draw(context, camera){
					let drawX = this.x-(camera.x-canvasWidth/2);
					let drawY = this.y-(camera.y-canvasHeight/2);
					context.font = "30px Arial";
					context.fillStyle = 'white';
					context.fillText(this.text, drawX, drawY);
				}
			}

 			class Blower extends Piece{
				constructor(sim, board, x, y, control){
					super(board, x, y)
					this.type = "blower";
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.blowAble = false;
					this.effect = {type: "none"};
					this.collider = false;

					this.sim = sim;
					this.board = board;
					this.control = control;
					this.angle = (Math.random()*Math.PI*2)-Math.PI;
					this.speed = 500;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					let angle = (this.angle/Math.PI)*180
					context.drawRotated(pieceSpec, Img.blower, camera, angle)
				}
				moveTick(dt){
					if(wDown){
						this.y -= this.speed*dt;
					}
					if(sDown){
						this.y += this.speed*dt;
					}
					if(aDown){
						this.x -= this.speed*dt;
					}
					if(dDown){
						this.x += this.speed*dt;
					}
				}
				particleTick(dt){
					MakeParticle(this.sim, "trail", this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*10), 0, 0, 0)
					if(this.blowing){
						for (var i = 0; i < 100*dt; i++) {
							let particleAngleMargin = degToRad(90)
							let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
							let velocity = 750;
							let xVel = velocity*Math.cos(particleAngle);
							let yVel = velocity*Math.sin(particleAngle);
							MakeParticle(this.sim, "force", this.x, this.y, xVel, yVel, radToDeg(particleAngle)+180)
						}
					}
				}
				ai(pieceList){
					let directionList = ["up", "down", "left", "right"]
					//if(Math.random() > 0.999){
					//	this.direction = directionList[Math.floor(Math.random()*4)]
					//}
					
				}
				tick(dt){
					if(this.control == "AI"){
						//this.ai(pieceList);
					}
					this.moveTick(dt);
					this.particleTick(dt)
					if(this.health <= 0 ){
						this.dead = true;
					}
				}
				grow(amount){
					this.length += amount*Rules.growSpeedMod*(this.speed+this.tempSpeed)/100;
				}
				speedBoost(amount){
					this.tempSpeed += amount*Rules.speedBoostMod;
				}
				strengthen(amount){
					this.strength += amount*Rules.strengthAddMod;
				}
				setTarget(x, y){
					this.angle = calcAngle(this.x, this.y, x, y);
				}
			}

			class Particle extends Piece{
				constructor(board, x, y, xVel, yVel, angle){
					super(board, x, y)
					this.width = 5;
					this.height = 5;
					this.xVel = xVel;
					this.yVel = yVel;
					this.blowAble = false;
					this.collider = false;
					this.lifeRemaining = Rules.blowRange/(xVel+yVel);
					this.angle = angle;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					if(this.angle == 0){
						context.draw(pieceSpec, Img[this.type], camera)
					}else{
						context.drawRotated(pieceSpec, Img[this.type], camera, this.angle)
					}
				}
				tick(dt){
					if(!this.dead){
						if(this.control == "AI"){
							//this.ai(pieceList);
						}
						this.x += this.xVel*dt;
						this.y += this.yVel*dt;

						this.xVel -= (this.xVel*Rules.friction)*dt;
						this.yVel -= (this.yVel*Rules.friction)*dt;

						this.lifeRemaining -= dt;
						if(this.lifeRemaining <= 0){
							this.dead = true;
						}
					}
				}
			}
			class Force extends Particle{
				constructor(board, x, y, xVel, yVel, angle){
					super(board, x, y, xVel, yVel, angle)
					this.width = 10;
					this.height = 10;
					this.type = "force";
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Trail extends Particle{
				constructor(board, x, y, xVel, yVel){
					super(board, x, y, xVel, yVel)
					this.width = 5;
					this.height = 5;
					this.angle = Math.random()*360;
					this.type = "trail";
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Electricity extends Particle{
				constructor(board, x, y, xVel, yVel){
					super(board, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.type = "electricity";
					this.lifeRemaining = Math.random()*0.2;
				}
			}
			class PortalEnergy extends Particle{
				constructor(board, x, y, xVel, yVel){
					super(board, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.type = "portalEnergy";
					this.lifeRemaining = 0.5;
				}
			}
			class Explosion extends Particle{
				constructor(board, x, y, xVel, yVel){
					super(board, x, y, xVel, yVel)
					this.width = 200;
					this.height = 200;
					this.angle = 0;
					this.type = "explosion";
					this.totalLife = 0.52;
					this.lifeRemaining = this.totalLife;
				}
				draw(context, camera){
					let frameCount = 13;
					let frame = Math.floor(((this.totalLife-this.lifeRemaining)/this.totalLife)*frameCount) //12 frames in the explosion image.
					let frameWidth = 2548/frameCount;
					let frameHeight = 190;

					let pieceSpec = {
						sx: frame*frameWidth,
						sy: 0,
						sw: frameWidth,
						sh: frameHeight,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};

					context.draw(pieceSpec, Img[this.type], camera)
				}
			}
			function MakeParticle(sim, type, x, y, xVel, yVel, angle){
				if(type == "force"){
					sim.pieceList.push(new Force(sim.board, x, y, xVel, yVel, angle))
				}
				if(type == "trail"){
					sim.pieceList.push(new Trail(sim.board, x, y, xVel, yVel))
				}
				if(type == "electricity"){
					sim.pieceList.push(new Electricity(sim.board, x, y, xVel, yVel))
				}
				if(type == "portalEnergy"){
					sim.pieceList.push(new PortalEnergy(sim.board, x, y, xVel, yVel))
				}
				if(type == "explosion"){
					sim.pieceList.push(new Explosion(sim.board, x, y, xVel, yVel))
				}
			}
 			//CONTROL
 			let wDown;
 			let sDown;
			let aDown;
			let dDown;
			function initControls(sim){
				let blower = sim.pieceList[0];
				let mouseX = 0;
				let mouseY = 0;
				$( document ).mousemove(function( event ) {
					mouseX = event.pageX+blower.x-canvasWidth/2;
					mouseY = event.pageY+blower.y-canvasHeight/2;
					blower.setTarget(mouseX, mouseY)
				});
				$( document ).mousedown(function( event ) {
					blower.blowing = true;
				});
				$( document ).mouseup(function( event ) {
					blower.blowing = false;
				});
				$( document ).keydown(function( event ) {
					if(event.key == "w"){
						wDown = true;
					}
					if(event.key == "s"){
						sDown = true;
					}
					if(event.key == "a"){
						aDown = true;
					}
					if(event.key == "d"){
						dDown = true;
					}
					if(level == 0){
						if(event.key == "0"){
							EditLevel(sim, levelPlan, "deletePiece")
						}
						if(event.key == "1"){
							EditLevel(sim, levelPlan, "blower", mouseX, mouseY)
						}
						if(event.key == "2"){
							EditLevel(sim, levelPlan, "destination", mouseX, mouseY)
						}
						if(event.key == "3"){
							EditLevel(sim, levelPlan, "payload", mouseX, mouseY)
						}
						if(event.key == "4"){
							EditLevel(sim, levelPlan, "block", mouseX, mouseY)
						}
						if(event.key == "5"){
							EditLevel(sim, levelPlan, "bomb", mouseX, mouseY)
						}
						if(event.key == "6"){
							EditLevel(sim, levelPlan, "destructible", mouseX, mouseY)
						}
						if(event.key == "7"){
							EditLevel(sim, levelPlan, "turret", mouseX, mouseY)
						}
					}
				});
				$( document ).keyup(function( event ) {
					if(event.key == "w"){
						wDown = false;
					}
					if(event.key == "s"){
						sDown = false;
					}
					if(event.key == "a"){
						aDown = false;
					}
					if(event.key == "d"){
						dDown = false;
					}
					
				});

			}
 			//VIEW
 			let ImageURLs = {
				blower: 'images/mover.png',
				payload: 'images/payload.png',
				destination: 'images/gate.png',
				bomb: 'images/mine.png',
				block: 'images/block.png',
				destructible: 'images/destructible.png',
				turret: 'images/turret.png',
				bullet: 'images/bullet.png',
				//wind: 'images/wind2.png',
				background: 'images/black.png',
				force: 'images/particles/force.png',
				trail: 'images/particles/trail.png',
				electricity: 'images/particles/lightning.png',
				portalEnergy: 'images/particles/trail.png',
				explosion: 'images/explosion.png',
				//minimapBackground: 'images/minimapBackground.jpg',
			};
 			let Img = {};
 			class View{
				constructor(){
 				}
				
 				imageLoad(imageURLs, target, callbackFn){
					let imagesRequested = 0;
					let imagesLoaded = 0;
					for(let key in imageURLs){
						let image = imageURLs[key];
						target[key] = new Image();
						target[key].onload = function(){
							imagesLoaded ++
						};
						target[key].src = image;
						imagesRequested ++;
					}
 					let handle = setInterval( () => {
						if( imagesLoaded >= imagesRequested ) {
							console.assert(imagesLoaded == imagesRequested)
							clearInterval(handle);
							displayTitleScreen();
						}
					},1)
				}
 				myCanvas(canvasId, board){
					var canvas = document.getElementById(canvasId);
					var context = canvas.getContext('2d');
					context.canvas.width = window.innerWidth;
					context.canvas.height = window.innerHeight;
					
					context.draw = function(spec, imageObj, camera){
						let drawX = spec.x-(camera.x-canvasWidth/2);
						let drawY = spec.y-(camera.y-canvasHeight/2);
						if(spec.xAnchor && spec.yAnchor){
							drawX -= spec.width*spec.xAnchor;
							drawY -= spec.height*spec.yAnchor;
						}
						if(spec.sx !== undefined){
							this.drawImage(imageObj, spec.sx, spec.sy, spec.sw, spec.sh, drawX, drawY, spec.width, spec.height);
						}else{
							this.drawImage(imageObj, drawX, drawY, spec.width, spec.height);
						}
					}.bind(context)
					context.clear = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, canvas.width, canvas.height);
					}.bind(context)
					/*context.clearMinimap = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, 280, 260);
					}.bind(context)*/
					context.drawRotated = function(spec, imageObj, camera, degrees){
						let x = spec.x-(camera.x-canvasWidth/2);
						let y = spec.y-(camera.y-canvasHeight/2);
						x -= spec.width*spec.xAnchor;
						y -= spec.height*spec.yAnchor;
						
						let w = spec.width;
						let h = spec.height;

						this.save();
						this.translate(x+w/2, y+h/2);
						this.rotate(degrees*Math.PI/180.0);
						this.translate(-x-w/2, -y-h/2);
						this.drawImage(imageObj, x, y, w, h);
						this.restore();
					}.bind(context)
					return context
				}
 				render(context, sim){
					context.clear();
 					let camera = {};
 					camera.x = sim.blower.x;
					camera.y = sim.blower.y;
 					for(let i = 0; i < sim.pieceList.length; i++){
						
						if(!sim.pieceList[i].dead){
							sim.pieceList[i].draw(context, camera)
						}
					}
				}
/*				renderMinimap(context, sim){
					context.clearMinimap()
					
					let camera = {};
 					camera.x = 100;
					camera.y = 100;

					let boardSizeMod = (sim.board.size/2000)

 					for(let i = 0; i < sim.pieceList.length; i++){
						let pieceSpec = {x: sim.pieceList[i].x/10, y: sim.pieceList[i].y/10, width: (sim.pieceList[i].width/10)/boardSizeMod, height: (sim.pieceList[i].height/10)/boardSizeMod, xAnchor: 0.5, yAnchor: 0.5};
						
						let drawX = (pieceSpec.x+(120*boardSizeMod))/boardSizeMod;
						let drawY = (pieceSpec.y+(130*boardSizeMod))/boardSizeMod;
						
						if(pieceSpec.xAnchor && pieceSpec.yAnchor){
							drawX -= pieceSpec.width*pieceSpec.xAnchor;
							drawY -= pieceSpec.height*pieceSpec.yAnchor;
						}

						if(!sim.pieceList[i].dead){
							context.drawImage(Img[sim.pieceList[i].type], drawX, drawY, pieceSpec.width, pieceSpec.height);
						}
					}

					let blowerSpec = {x: sim.pieceList[0].x/10, y: sim.pieceList[0].y/10, width: 10, height: 10, xAnchor: 0.5, yAnchor: 0.5};

					let drawX = (blowerSpec.x+(120*boardSizeMod))/boardSizeMod;
					let drawY = (blowerSpec.y+(130*boardSizeMod))/boardSizeMod;
					
					if(blowerSpec.xAnchor && blowerSpec.yAnchor){
						drawX -= blowerSpec.width*blowerSpec.xAnchor;
						drawY -= blowerSpec.height*blowerSpec.yAnchor;
					}
					context.drawImage(Img.blower, drawX, drawY, blowerSpec.width, blowerSpec.height);
					
				}*/
			}
 			//ORGANIZATION
			function displayTitleScreen(){
				$("#canvas").hide()
				$("#debrief").hide()
				$("#gameOverScreen").hide()
				$("#levelSelect").hide()
				$("#titleScreen").show()
			}
			function displayLevelSelect(){
				$("#gameOverScreen").hide()
				$("#titleScreen").hide()
				$("#levelSelect").show()
				$("#levelSelect").html('');
				for (let i = 1; i < LevelList.length; i++) {
					$("#levelSelect").append('<button class="menuButton" onClick="level = '+i+'; levelPlan = LevelList[level]; Main()">'+i+'</button>');
				}
				$("#levelSelect").prepend('<h1 class="menuTitle">Choose A Level</h1>')
				$("#levelSelect").append('<br> </br> <button class="menuButton" onClick="level = 0; levelPlan = LevelList[0]; Main()">Level Builder</button> <br> </br> <button class="menuButton" onClick="displayTitleScreen()">Back</button>');
			}
			function displayGameOverScreen(win){
				$("#canvas").hide()
				$("#levelSelect").hide()
				$("#menus").show()
				$("#gameOverScreen").show()
				if(win){
					$("#gameOverScreen").html('<h1 class="menuTitle">You Win!</h1> <button class="menuButton" onClick="displayLevelSelect()">Main Menu</button> <button class="menuButton" onClick="level = '+level+'; levelPlan = LevelList[level]; Main()">Play Again</button> <button class="menuButton" onClick="level = '+(level+1)+'; levelPlan = LevelList[level]; Main()">Next Level</button>');
				}else{
					$("#gameOverScreen").html('<h1 class="menuTitle">You Lose!</h1> <button class="menuButton" onClick="displayLevelSelect()">Main Menu</button> <button class="menuButton" onClick="level = '+level+'; levelPlan = LevelList[level]; Main()">Try Again</button>');
				}
			}
			function displayDebrief(){
				$("#titleScreen").hide()
				$("#debrief").show()
			}
 			function GameOver(handleView, win){
 				cancelAnimationFrame(handleView)
 				displayGameOverScreen(win)
			}

 			function Main(){
 				//level = prompt("Which level would you like to play?");
				wDown = false;
				sDown = false;
				aDown = false;
				dDown = false;

				$("#menus").hide()
				$("#canvas").show()
				let view = new View();
				let board = new Board(Rules.boardSize);
				let context = view.myCanvas('canvas', board);
				let sim = new Sim(board);
				initControls(sim);
					let levelPlan = LevelList[level]
				function tickSim(){
					let levelPlan = LevelList[level]
					if(sim.pieceList[2].type != "payload"){
						 setTimeout(() => {setTimeout(GameOver(handleView, false))},1000)
					}

					sim.timeSinceLastSim = 0;
					let dt;
					let now = Date.now();
					if(sim.nowPrior === null){
						dt = 1.0/FPS;
					}else{
						dt = (now - sim.nowPrior)/1000;
					}
					sim.nowPrior = now;
					sim.timeSinceLastSim += dt;
					while(sim.timeSinceLastSim > 1/FPS){
						sim.piecesBlown(dt);
						if(sim.piecesTouched() == "next level"){
							return "next level"
						}
						sim.tick(1/FPS);
						sim.timeSinceLastSim -= 1/FPS;
					}
				}
 				function tickView(){
					view.render(context, sim);
					//view.renderMinimap(context, sim);
				}

				$("#titleScreen").hide()

				let handleView;
				function animateView(){
					tickView()
					handleView = requestAnimationFrame( animateView );
					if(tickSim() == "next level"){
						GameOver(handleView, true)
					}
				}
 				animateView();
			}
			$(document).ready(function(){	
 				$("#titleScreen").hide() //temporary for dev
 				
 				canvasWidth = $("#canvas").width();
				canvasHeight = $("#canvas").height();
				console.assert(canvasWidth > 0)
				console.assert(canvasHeight > 0)

				let view = new View();
				view.imageLoad(ImageURLs, Img, Main);
				
				$(window).resize(function(){
					let canvasId = "canvas"
					let canvas = document.getElementById(canvasId);
					let context = canvas.getContext('2d');
					context.canvas.width = window.innerWidth;
					context.canvas.height = window.innerHeight;
	 				canvasWidth = $("#canvas").width();
					canvasHeight = $("#canvas").height();
				})
			});
			
			//art by: eleksey goldis
    </script>
  </body>
</html>        
		</script>
	</head>
	<body>
		<div id="menus">
			<div id="titleScreen" class="menu">
				<h1 class="menuTitle">
					Blower Game
				</h1>
				<button class="menuButton" onClick="displayDebrief()">
					Debriefing
				</button>
				<button class="menuButton" onClick="level = 1; levelPlan = LevelList[level]; Main()">
					Play
				</button>
				<button class="menuButton" onClick="displayLevelSelect()">
					Level Select
				</button>
			</div>
			<div id="debrief" class="menu">
				<h1 class="menuTitle">
					Your Debrief
				</h1>
				<pre class="menuText">
	The enemy has stolen the Quanum Arc-Reactor and placed it deep behind enemy lines.
	You must get it back to high command.

	We can get you to the Arc-Reactor, but you will have to get out.
	Just push it through the blue warp gates and they will lead you back to high command.

	However, they have experimented with it and it is unstable.
	If it touches anything, it will go critical and destroy one third of the galaxy.
	This is why you must get it back to us with only your repulser field.

	Good Luck.
				</pre>
				<button class="menuButton" onClick="displayTitleScreen()">
					Understood
				</button>
			</div>
			<div id="levelSelect" class="menu">
				<h1 class="menuTitle">
					Choose A Level
				</h1>
			</div>
			<div id="gameOverScreen" class="menu">
			</div>
		</div>
		<div id="canvasDiv" width="100%" height="100%">
			<canvas id="canvas" width="100%" height="100%"></canvas>
		</div>
	</body>
</html>