<html>
	<head>
		<style type="text/css">
			#canvas{
				width: 100%;
				height: 120%;
			}
			#titleScreen{
				margin-left: 100;
			}
			#title{
				font-size: 500%;
			}
			#playButton{
				width: 100px;
       			height: 50px;
			}
		</style>
		<title> Blower Game </title>
		<link rel="stylesheet" type="text/css" href="minireset.css">
		<script
  src="https://code.jquery.com/jquery-3.3.1.js"
  integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
  crossorigin="anonymous"></script>
  <script src="levels.js" charset="utf-8"></script>
		<script>
			/*
				
			*/
			let Rules = {boardSize: 2000}
			

			let ruleSets = {
				normal: {
					blowerCount: 5,
					bombDensity: (0.1),
					blockDensity: 0.01,
					speedMod: 3,
					blowRange: 200,
					blowForce: 0.1,
				}
			}

			let canvasWidth;
			let canvasHeight;

			let LevelList = MakeLevelList();

			Rules = Object.assign(Rules, ruleSets.normal)


 			function degToRad(deg){
				return deg/180*Math.PI;
			}
			/*
			function normalizeRads(rad){
				while(Math.abs(rad) > Math.PI){
					if(rad > 0){
						rad -= Math.PI*2;
					}else{
						rad += Math.PI*2;
					}
				}
				return rad;
			}
			*/
			function calcDist(x1, y1, x2, y2){
				let dx = (x1-x2);
				let dy = (y1-y2);
				return Math.abs(Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2)))
			}
			function askName(){
				let name = undefined;
				while(name == undefined){
					name = prompt("What's your worm's name?", generateName())
				}
				return name;
			}
			function pickRandom(list){
				let seed = Math.floor(Math.random()*list.length);
				return list[seed]
			}
			function calcAngle(x1, y1, x2, y2){
				let dx = (x2-x1);
				let dy = (y2-y1);
				let rad = Math.atan2(dy,dx)
				return rad;
			}
			function generateName(){
				let name = "";
				
				let prefixList = ["The", "The Great", "Ultra", "Mega", "Epic", "Crazy", "Sir", "Mr.", "Madam", "Edgy", "Speedy", "Derpy", "Fluffy", "King", "Satanic", "Grumpy", "Dumpster", "Constipated", "Genius", "'lil", "Deadly", "Lord", "The Dark Lord"]
				let affixList = ["Kitten", "Worm Dude", "Butt", "Worm", "Wormatron", "Dude", "Donut Worm", "Fluffykins", "Idiot", "Dragon", "Bob", "Joe", "Turd", "God"]
				let suffixList = ["The Great", "Mc Wormface", "The Worm"]
				
				let prefix = (Math.random() > (suffixList.length/prefixList.length) ? true : false)
				if(prefix){
					name += pickRandom(prefixList)
					name += " ";
					name += pickRandom(affixList)
				}else{
					name += pickRandom(affixList)
					name += " ";
					name += pickRandom(suffixList)
				}

				if((Math.random() > 0.95 ? true : false)){
					name = "Visit playCandyhop.com"
				}

				return name;
			}
			class Board{
				constructor(size){
					this.size = size;
				}
				pickRandomLocation(){
					return Math.random()*this.size-(this.size/2)
				}
			}
 			class Sim{
 				constructor(board, name){
 					this.pieceList = [];
					
					this.addPiece = (x, y, type) => {
 						if(type == "blower"){
							return this.pieceList.push(new Blower(board, x, y))
						}
 						if(type == "payload"){
							return this.pieceList.push(new Payload(board, x, y))
						}
						if(type == "destination"){
							return this.pieceList.push(new Destination(board, x, y))
						}
						if(type == "bomb"){
							return this.pieceList.push(new Bomb(board, x, y))
						}
						if(type == "block"){
							return this.pieceList.push(new Block(board, x, y))
						}
					}
					this.nowPrior = null;
 					this.board = board;

 					let level = 1;

 					let levelPlan = LevelList[level]

 					for (let i = 0; i < levelPlan.length; i++) {
 						let object = levelPlan[i];
					
						this.addPiece(object.x, object.y, object.type)
					}

					this.blower = this.pieceList[0];

 					/*
 					for (let i = 0; i < Rules.blowerCount; i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
					
						this.blowerList.push (new Blower(board, x, y, "AI"));
					}
 					this.blower = this.blowerList[0];
 					this.pieceList = [];
 					for (let i = 0; i < (1); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "payload")
					}
					for (let i = 0; i < (1); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "destination")
					}
					for (let i = 0; i < (Rules.bombDensity*(board.size^2)); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "bomb")
					}
					for (let i = 0; i < (Rules.blockDensity*(board.size^2)); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "block")
					}
					*/
 				}
 				tick(dt){
					this.pieceList.forEach(piece => piece.tick())
				}
 				piecesBlown(){
					if(this.pieceList[0].blowing){
						let blower = this.pieceList[0];
						for(let i = 0; i < this.pieceList.length; i++){
							let piece = this.pieceList[i];
							if(!piece.blowAble){
								continue;
							}
							let angle = calcAngle(blower.x, blower.y, piece.x, piece.y);
							let blowArc = degToRad(45);
							let dist = calcDist(blower.x, blower.y, piece.x, piece.y);
							if(blower.pointingRad < angle+blowArc && blower.pointingRad > angle-blowArc && dist < Rules.blowRange){
								let velIncrease = ((Rules.blowRange-calcDist(blower.x, blower.y, piece.x, piece.y))*Rules.blowForce)/piece.mass;
								piece.xVel -= velIncrease*((blower.x - piece.x)/dist)
								piece.yVel -= velIncrease*((blower.y - piece.y)/dist)
								piece.lit = true;
							}else{
								piece.lit = false;
							}
						}
					}
				}
 				piecesTouched(){
					this.pieceList.forEach(piece => {
						for(let i = 0; i < this.pieceList.length; i++){
							let piece2 = this.pieceList[i];
							if(Math.abs(piece.x - piece2.x)+Math.abs(piece.y - piece2.y) < (piece.width+piece2.width)/2){
								piece.applyEffect(piece2.effect)
							}
						}
					})
				}
			}
			class Piece{
				constructor(board, x, y){
					this.board = board;
					this.x = x;
					this.y = y;
					this.xVel = 0;
					this.yVel = 0;
					this.type;
					this.width;
					this.height;
					this.effect;
				}
				applyEffect(effect){
					if(effect.type == "damage"){
						this.health -= effect.amount;
					}
					if(effect.type == "win" && this.type == "destination"){
						alert("U like win 'n' stuf,?")
					}
				}
				tick(){
					if(!this.dead){
						if(this.control == "AI"){
							//this.ai(pieceList);
						}
						this.x += this.xVel;
						this.y += this.yVel;

						this.xVel *= 0.99;
						this.yVel *= 0.99;

						if(this.x > this.board.size/2){
							this.x -= this.board.size;
						}
						if(this.x < -this.board.size/2){
							this.x += this.board.size;
						}
						if(this.y > this.board.size/2){
							this.y -= this.board.size;
						}
						if(this.y < -this.board.size/2){
							this.y += this.board.size;
						}
						if(this.health < 1){
							this.dead = true;
						}
					}
				}
			}

			class Payload extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "payload";
					this.mass = 50;
					this.width = 40;
					this.height = 40;
					this.blowAble = true;
					this.effect = {type: "win", amount: 10};
					this.health = 10;
				}
			}

			class Destination extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "destination";
					this.mass = 50;
					this.width = 50;
					this.height = 50;
					this.blowAble = false;
					this.effect = {type: "none"};
				}
			}

 			class Bomb extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "bomb";
					this.mass = 10;
					this.width = 10;
					this.height = 10;
					this.blowAble = true;
					this.effect = {type: "damage",};
				}
			}

			class Block extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "block";
					this.mass = 1;
					this.width = 50;
					this.height = 50;
					this.blowAble = false;
					this.effect = {type: "damage", amount: 10};
				}
			}

 			class Blower extends Piece{
				constructor(board, x, y, control, name){
					super(board, x, y)
					this.type = "blower";
					this.mass = 1;
					this.width = 50;
					this.height = 50;
					this.blowAble = false;
					this.effect = {type: "none"};

					this.board = board;
					this.control = control;
					this.pointingRad = (Math.random()*Math.PI*2)-Math.PI;
					this.speed = 10;
					this.name = (name ? name : generateName())
					this.air = 100;
					this.direction = "up"
				}
				moveTick(){
					if(wDown){
						this.y -= this.speed;
					}
					if(sDown){
						this.y += this.speed;
					}
					if(aDown){
						this.x -= this.speed;
					}
					if(dDown){
						this.x += this.speed;
					}
				}
				airTick(){
					if(!this.blowing && this.air < 100){
						this.air ++;
					}
					if(this.blowing){
						this.air -= 2;
					}
					if(this.air <= 0){
						this.blowing = false;
					}
				}
				ai(pieceList){
					let directionList = ["up", "down", "left", "right"]
					//if(Math.random() > 0.999){
					//	this.direction = directionList[Math.floor(Math.random()*4)]
					//}
					
				}
				tick(dt, pieceList){
					if(this.control == "AI"){
						//this.ai(pieceList);
					}
					this.moveTick();
					this.airTick()
					if(this.health <= 0 ){
						this.dead = true;
					}
				}
				grow(amount){
					this.length += amount*Rules.growSpeedMod*(this.speed+this.tempSpeed)/100;
				}
				speedBoost(amount){
					this.tempSpeed += amount*Rules.speedBoostMod;
				}
				strengthen(amount){
					this.strength += amount*Rules.strengthAddMod;
				}
				setTarget(x, y){
					this.pointingRad = calcAngle(this.x, this.y, x, y);
				}
			}
 			//CONTROL
 			let wDown = false;
 			let sDown = false;
			let aDown = false;
			let dDown = false;
			function initControls(blower){
				$( document ).mousemove(function( event ) {
					let mouseX = event.pageX+blower.x-canvasWidth/2;
					let mouseY = event.pageY+blower.y-canvasHeight/2;
					blower.setTarget(mouseX, mouseY)
				});
				$( document ).mousedown(function( event ) {
					blower.blowing = true;
				});
				$( document ).mouseup(function( event ) {
					blower.blowing = false;
				});
				$( document ).keydown(function( event ) {
					if(event.key == "w"){
						wDown = true;
					}
					if(event.key == "s"){
						sDown = true;
					}
					if(event.key == "a"){
						aDown = true;
					}
					if(event.key == "d"){
						dDown = true;
					}
					
				});
				$( document ).keyup(function( event ) {
					if(event.key == "w"){
						wDown = false;
					}
					if(event.key == "s"){
						sDown = false;
					}
					if(event.key == "a"){
						aDown = false;
					}
					if(event.key == "d"){
						dDown = false;
					}
					
				});

			}
 			//VIEW
 			let ImageURLs = {
				blower: 'images/roomba2.png',
				payload: 'images/blueCircle.png',
				destination: 'images/blueCircle.png',
				bomb: 'images/orangeCircle.png',
				block: 'images/orangeCircle.png',
				wind: 'images/wind2.png',
				background: 'images/black.png',
				//minimapBackground: 'images/minimapBackground.jpg',
			};
 			let Img = {};
 			class View{
				constructor(){
 				}
				
 				imageLoad(imageURLs, target, callbackFn){
					let imagesRequested = 0;
					let imagesLoaded = 0;
					for(let key in imageURLs){
						let image = imageURLs[key];
						target[key] = new Image();
						target[key].onload = function(){
							imagesLoaded ++
						};
						target[key].src = image;
						imagesRequested ++;
					}
 					let handle = setInterval( () => {
						if( imagesLoaded >= imagesRequested ) {
							console.assert(imagesLoaded == imagesRequested)
							clearInterval(handle);
							//callbackFn();
						}
					},1)
				}
 				myCanvas(canvasId, board){
					var canvas = document.getElementById(canvasId);
					var context = canvas.getContext('2d');
					
					context.draw = function(spec, imageObj, camera){
						let drawX = spec.x-(camera.x-canvasWidth/2);
						let drawY = spec.y-(camera.y-canvasHeight/2);
						if(spec.xAnchor && spec.yAnchor){
							drawX -= spec.width*spec.xAnchor;
							drawY -= spec.height*spec.yAnchor;
						}
						this.drawImage(imageObj, drawX, drawY, spec.width, spec.height);
					}.bind(context)
 					context.clear = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, 1200, 800);
					}.bind(context)
					context.clearMinimap = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, 280, 260);
					}.bind(context)
					return context
				}
 				render(context, sim){
					context.clear();
 					let camera = {};
 					let blowerSpec = {x: 100, y: 100, width: 50, height: 50, xAnchor: 0.5, yAnchor: 0.5};
 					camera.x = sim.blower.x;
					camera.y = sim.blower.y;
 					for(let i = 0; i < sim.pieceList.length; i++){
						let pieceSpec = {
							x: sim.pieceList[i].x,
							y: sim.pieceList[i].y,
							width: sim.pieceList[i].width,
							height: sim.pieceList[i].height,
							xAnchor: 0.5,
							yAnchor: 0.5
						};
						
						if(!sim.pieceList[i].dead){
							context.draw(pieceSpec, Img[sim.pieceList[i].type], camera)
						}
					}

					context.font = "20px Arial";
					context.fillStyle = "white";
					context.fillText(sim.blower.name, 530, 405);
				}
				renderMinimap(context, sim){
					context.clearMinimap()
					
					let camera = {};
 					camera.x = 100;
					camera.y = 100;

					let boardSizeMod = (sim.board.size/2000)

 					for(let i = 0; i < sim.pieceList.length; i++){
						let pieceSpec = {x: sim.pieceList[i].x/10, y: sim.pieceList[i].y/10, width: (sim.pieceList[i].width/10)/boardSizeMod, height: (sim.pieceList[i].height/10)/boardSizeMod, xAnchor: 0.5, yAnchor: 0.5};
						
						let drawX = (pieceSpec.x+(120*boardSizeMod))/boardSizeMod;
						let drawY = (pieceSpec.y+(130*boardSizeMod))/boardSizeMod;
						
						if(pieceSpec.xAnchor && pieceSpec.yAnchor){
							drawX -= pieceSpec.width*pieceSpec.xAnchor;
							drawY -= pieceSpec.height*pieceSpec.yAnchor;
						}

						if(!sim.pieceList[i].dead){
							context.drawImage(Img[sim.pieceList[i].type], drawX, drawY, pieceSpec.width, pieceSpec.height);
						}
					}

					let blowerSpec = {x: sim.pieceList[0].x/10, y: sim.pieceList[0].y/10, width: 10, height: 10, xAnchor: 0.5, yAnchor: 0.5};

					let drawX = (blowerSpec.x+(120*boardSizeMod))/boardSizeMod;
					let drawY = (blowerSpec.y+(130*boardSizeMod))/boardSizeMod;
					
					if(blowerSpec.xAnchor && blowerSpec.yAnchor){
						drawX -= blowerSpec.width*blowerSpec.xAnchor;
						drawY -= blowerSpec.height*blowerSpec.yAnchor;
					}
					context.drawImage(Img.blower, drawX, drawY, blowerSpec.width, blowerSpec.height);
					
				}
			}
 			//ORGANIZATION
 			function GameOver(sim, handleSim, handleView){
 				let leaderBoard = ""
 				leaderBoard += "<b> Name                     | Length</b>\n"
 				
 				let blower = sim.pieceList[0];
				leaderBoard += " "+blower.name;
				for(let j = 0; j < 25 - blower.name.length; j++){
					leaderBoard += " "
				}
				leaderBoard += "| "+Math.floor(blower.length)+"\n";

 				clearInterval(handleSim)
				clearInterval(handleView)


 				$("#leaderBoard").html(leaderBoard);
 				$("#leaderBoard").show()
 				$("#titleScreen").show()
 				//$("#playAgain").show()
 				$("#canvas").hide()
 				$("#stats").hide()
 			}

 			function Main(){
 				$("#leaderBoard").hide()
				$("#playAgain").hide()
				$("#canvas").show()
				$("#stats").show()
				let view = new View();
 				let board = new Board(Rules.boardSize);
 				let context = view.myCanvas('myCanvas', board);
 				let sim = new Sim(board, $("#nameInput").val());
 				initControls(sim.blower);
 				function tickSim(){
 					if(sim.blower.dead){
 						GameOver(sim, handleSim, handleView)
 					}

					sim.timeSinceLastSim = 0;
					let dt;
					let now = Date.now();
					if(sim.nowPrior === null){
						dt = 1.0/60
					}else{
						dt = (now - sim.nowPrior)/1000;
					}
					sim.nowPrior = now;
					sim.timeSinceLastSim += dt;
					while(sim.timeSinceLastSim > 1/60){
						sim.piecesBlown(sim.blower);
						sim.piecesTouched();
						$("#stats").html(" Health: "+(Math.floor(sim.blower.health))+" Air: "+(Math.floor(sim.blower.air))+" Strength: "+sim.blower.strength);
						sim.tick(1/60, sim.pieceList);
						sim.timeSinceLastSim -= 1/60;
					}
				}
 				function tickView(){
					view.render(context, sim);
					view.renderMinimap(context, sim);
				}

				$("#titleScreen").hide()

 				let handleSim = setInterval(tickSim, (1000/60))
				let handleView = setInterval(tickView, (1000/60))
			}
 			$( document ).ready(function(){	
 				canvasWidth = $("#canvas").width();
				canvasHeight = $("#canvas").height();
				console.assert(canvasWidth > 0)
				console.assert(canvasHeight > 0)

				let view = new View();
				view.imageLoad(ImageURLs, Img, Main);
			});
			
			
    </script>
  </body>
</html>        
		</script>
	</head>
	<body>
		<div id="titleScreen">
			<h1 id="title">
				Blower Game
			</h1>
			<form>
				Name: <input type="text" id="nameInput"></input>
			</form>
			<button id="playButton" onClick="Main()">
				Play!
			</button>
			<pre id="leaderBoard">

			</pre>
		</div>
		<div id="stats">
			
		</div>
		<div id="canvas">
			<canvas id="myCanvas" width="1000" height="790"></canvas>
		</div>
		<button id="playAgain" onclick="Main()">Play Again</button>
	</body>
</html>