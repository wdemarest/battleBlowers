<html>
	<head>
		<link rel="stylesheet" type="text/css" href="minireset.css">
		<style type="text/css">
			html, body{
				height: 100%;
				overflow: hidden;
			}
			#canvas{
				width: 100%;
				height: 100%;
				cursor: crosshair;
			}
			#menus{
				border: 1px solid black;
				height: 100%;
				background-size: cover;
				background-repeat: no-repeat;
				background-image: url('images/monitor.jpg');
			}
			.menu{
				margin-left: 15%;
				margin-top: 6%;
			}
			.mainTitle{
				font-size: 500%;
				font-family: "impact";
			}
			#pauseMenuOuter{
				display: none;
				background-color: rgba(0, 0, 0, 0.75);
				z-index: 10;
				position: absolute;
				width: 100%;
				height: 100%;
				align-items: center;
			}
			#pauseMenu{
				background-color: rgba(54, 178, 262, 0.25);
				z-index: 11;
				margin-left: auto;
				margin-right: auto;
				width: 800;
				padding: 32px;
			}
			.ctr{
				text-align: center;
			}
			.pauseMenuTitle{
				text-align: center;
 				margin-bottom: 32px;
			}
			.menuTitle{
				font-size: 500%;
				font-family: "impact";
				color: rgb(6, 17, 22);
				text-shadow:
					-1px -1px 0 #acbccc,
					1px -1px 0 #acbccc,
					-1px 1px 0 #acbccc,
					1px 1px 0 #acbccc;
			}
			.menuText{
				font-size: 150%;
				font-family: "courier";
			}
			.menuText p{
				padding-bottom: 20px;
				width: 75%;
			}
			.menuButton, .bigMenuButton{
				width: 235px;
				font-size: 200%;
				font-family: "Arial";
				border-radius: 10px;
				color: rgb(220, 220, 220);
				background-color: rgba(0, 0, 0, 0);
				margin-top: 2px;
				margin-bottom: 2px;
				border: 1px solid rgb(220, 220, 220);
			}
			.menuButton:hover, .bigMenuButton:hover{
				margin-top: 1px;
				margin-bottom: 1px;
				border: 2px solid white;
			}
			.levelButton{
				margin-left: 2px;
				margin-right: 2px;
				width: 60px;
				text-align: center;
			}
			.bigMenuButton{
				font-size: 300%;
			}
			#playButton{
				width: 100px;
	   			height: 50px;
			}
		</style>
		<title>Reactor Rescue</title>
		<script
			src="https://code.jquery.com/jquery-3.3.1.js"
			integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
			crossorigin="anonymous">
		</script>
		<script src="levels.js" charset="utf-8"></script>
		<script src="debug.js" charset="utf-8"></script>
		<script src="howler2.js" charset="utf-8"></script>
		<script>
			let Rules = {boardSize: 2000}
			let FPS = 60;
			let counter = 0;
			

			let ruleSet = {
				speedMod: 3,
				blowRange: 200,
				blowForce: 100,
				friction: 1,
				minSpeed: 1,
				playerSpeed: 500,
				gameSpeed: 0,
				volume: 0.1,
				musicVolume: 0.03,
				isDemo: false,
				demoLevelLimit: 8,
				zOrders: {text: -1, particle: 0, blower: 1, payload: 2, bullet: 3, mine: 4, destructible: 5, turret: 6, barricade: 7, gate: 8, receptical: 8}
			}

			let canvasWidth;
			let canvasHeight;
			let handleView;

			let Cinematic = false;

			let LevelList = MakeLevelList();

 			let level;

 			let levelPlan;

 			let debug = new Debug;

			Rules = Object.assign(Rules, ruleSet)

			function SoundBank(){
				var list = [];
				var handle = {};
				this.load = function(name, src, volume) {
					list[name] = new Howl({
						src: [src],
						volume: (volume || 1.0)*Rules.volume
					});
				};
				this.loadLoop = function(name, params) {
					list[name] = new Howl(params);
				};
				this.play = function(name) {
					handle[name] = list[name].play();
					return handle[name];
				};
				this.playLoop = function(name) {
					handle[name] = list[name].play("main");
					return handle[name];
				};
				this.stop = function(name) {
					if( handle[name] ) {
						list[name].stop(handle[name]);
					}
				};
				this.stopAll = function() {
					for( var name in list ) {
						this.stop(name);
					}
				}
				return this;
			}
			let soundBank = new SoundBank;
			$(document).on('click',".menuButton", function(){
				soundBank.play("click");
			});
			function degToRad(deg){
				return (deg/180*Math.PI);
			}
			function radToDeg(rad){
				return (rad/Math.PI*180)+180;
			}
			/*
			function normalizeRads(rad){
				while(Math.abs(rad) > Math.PI){
					if(rad > 0){
						rad -= Math.PI*2;
					}else{
						rad += Math.PI*2;
					}
				}
				return rad;
			}
			*/
			function randInt(max) {
				return Math.floor(Math.random()*max);
			}

			function calcDist(x1, y1, x2, y2){
				let dx = (x1-x2);
				let dy = (y1-y2);
				return Math.abs(Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2)))
			}
			function pickRandom(list){
				let seed = randInt(list.length);
				return list[seed]
			}
			function calcAngle(x1, y1, x2, y2){
				let dx = (x2-x1);
				let dy = (y2-y1);
				let rad = Math.atan2(dy,dx)
				return rad;
			}
			function isWithinArc(sourceRad, targetRad, arc){
				let a0 = sourceRad;
				let a1 = sourceRad - Math.PI*2;
				let a2 = sourceRad + Math.PI*2;
				let min = targetRad - arc;
				let max = targetRad + arc;

				if(
					(a0 >= min && a0 <= max) ||
					(a1 >= min && a1 <= max) ||
					(a2 >= min && a2 <= max)
				){
					return true;
				}
				return false;
			}

			function MakeStars() {
				window.star = [];
				let w = canvasWidth;
				let h = canvasHeight;
				for( let i=0 ; i<150 ; ++i ) {
					let depth = 0.3+Math.random()*0.65;
					window.star[i] = {
						img: Img['star'+randInt(5)],
						x: randInt(w*1.3/depth),
						y: randInt(h*1.3/depth),
						xSpan: (w+randInt(w*0.3)),
						ySpan: (h+randInt(h*0.3)),
						depth: depth
					}
				}
			}

			class Board{
				constructor(size){
					this.size = size;
 					this.earthIsOn = false;
				}
				pickRandomLocation(){
					return Math.random()*this.size-(this.size/2)
				}
				get xMin() { return -this.size/2; }
				get xMax() { return this.size/2; }
				get yMin() { return -this.size/2; }
				get yMax() { return this.size/2; }
				contains(x,y) {
					return x>=this.xMin && x<=this.xMax && y>=this.yMin && y<=this.yMax;
				}
				clamp(x,y) {
					return [Math.min(Math.max(x,this.xMin),this.xMax),Math.min(Math.max(y,this.yMin),this.yMax)];
				}
			}
 			class Sim{
 				constructor(board){
 					this.pieceList = [];

					this.nowPrior = null;
 					this.board = board;
 					this.gameFailLatch = false;

 					for (let i = 0; i < levelPlan.pieceSource.length; i++) {
 						let object = levelPlan.pieceSource[i];
					
						this.addPiece(object.x, object.y, object.type, object)
					}
 				}
				addPiece(x, y, type, object){
					let newPiece;
					let board = this.board
					if(type == "blower"){
						newPiece = (new Blower(this, board, x, y))
					}
					if(type == "payload"){
						newPiece = (new Payload(this, board, x, y))
					}
					if(type == "gate"){
						newPiece = (new Gate(board, x, y))
					}
					if(type == "receptical"){
						newPiece = (new Receptical(this, board, x, y))
					}
					if(type == "mine"){
						newPiece = (new Mine(board, x, y))
					}
					if(type == "barricade"){
						newPiece = (new Barricade(board, x, y))
					}
					if(type == "destructible"){
						newPiece = (new Destructible(board, x, y))
					}
					if(type == "turret"){
						newPiece = (new Turret(this, board, x, y, object.fireDelay, object.bulletSpeed))
					}
					if(type == "bullet"){
						newPiece = (new Bullet(board, x, y, object.xVel, object.yVel))
					}
					if(type == "text"){
						newPiece = (new Text(board, x, y, object.text, object.condition))
					}
					this.pieceList.push(newPiece)
				}
				find(type){
 					return this.pieceList.find((piece)=>piece.type == type);
 				}
 				exists(type){
 					return !!this.find(type);
 				}
 				get blower(){
 					return this.find("blower");
 				}
 				get payload(){
 					return this.find("payload");
 				}
 				tick(dt){
					this.pieceList.forEach(piece => piece.tick(dt))
					for (var i = 0; i < this.pieceList.length; i++){
						if(this.pieceList[i].dead && !this.pieceList[i].warping){
							this.pieceList.splice(i, 1)
						}
					}
				}
 				piecesBlown(dt){
 					let blower = this.blower;
 					if(!blower){return}
					if(blower.blowing){
						for(let i = 0; i < this.pieceList.length; i++){
							let piece = this.pieceList[i];
							if(!piece.blowable){
								continue;
							}
							let angle = calcAngle(blower.x, blower.y, piece.x, piece.y);
							let blowArc = degToRad(45);
							let dist = calcDist(blower.x, blower.y, piece.x, piece.y);
							if(isWithinArc(blower.angle, angle, blowArc) && dist < Rules.blowRange){
								let velIncrease = (((Rules.blowRange-calcDist(blower.x, blower.y, piece.x, piece.y))*Rules.blowForce)/piece.mass)*dt;
								piece.xVel -= velIncrease*((blower.x - piece.x)/dist)
								piece.yVel -= velIncrease*((blower.y - piece.y)/dist)
							}
						}
					}else{
						console.log()
					}
				}
 				piecesTouched(){
 					let nextLevel = false;
					this.pieceList.forEach(piece => {
						if(piece.dead || !piece.collider){
							return;
						}
						for(let i = 0; i < this.pieceList.length; i++){
							let piece2 = this.pieceList[i];
							if(piece2.dead || !piece2.collider){
								continue;
							}
							if(piece == piece2){
								continue;
							}
							if(calcDist(piece.x, piece.y, piece2.x, piece2.y) < (piece.hitBoxRadius+piece2.hitBoxRadius)){
								if(piece.onTouch(piece2.effect) == "next level"){
									nextLevel = true;
								}
							}
						}
					})
					if(nextLevel){
						return "next level"
					}
				}
			}

			class Piece{
				constructor(type, board, x, y, isParticle){
					debug.expect(board, "object", "board")
					debug.expectNum(x, "x")
					debug.expectNum(y, "y")
					this.board = board;
					this.type = type;
					this.x = x;
					this.y = y;
					let z;
					if(isParticle){
						z = Rules.zOrders.particle;
					}else{
						z = Rules.zOrders[this.type];
					}
					debug.expectNum(z, "z")
					this.z = z+Math.random();
					this.xVel = 0;
					this.yVel = 0;
					this.mass = 1;
					this.width;
					this.height;
					this.hitBoxRadius;
					this.effect;
					this.collider = true;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.draw(pieceSpec, Img[this.type], camera)
				}
				onTouch(effect){
					if(effect.type == "damage"){
						this.health -= effect.amount;
					}
					if(effect.type == "win" && this.type == "payload" && !this.warping){
						soundBank.play("warpOut")
						this.x = effect.x;
						this.y = effect.y;
						this.warping = true;
						return "next level";
					}
					if(effect.type == "attach" && this.type == "payload"){
						if(!this.attached){
							soundBank.stop("gameMusic")
							soundBank.playLoop("victoryMusic")
							soundBank.play("woosh")
							soundBank.play("charging")
							setTimeout(()=>{this.board.earthIsOn = true; soundBank.play("turnOn")}, 7500)
							setTimeout(()=>this.sim.blower.credits = true, 12500)
						}
						this.x = effect.x;
						this.y = effect.y;
						this.attached = true;
						this.xVel = 0;
						this.yVel = 0;

					}
				}
				applyVelocity(dt){
					let velocity = Math.sqrt(this.xVel*this.xVel+this.yVel*this.yVel);
					if( velocity > Rules.minSpeed ) {
						this.x += this.xVel*dt*Rules.gameSpeed;
						this.y += this.yVel*dt*Rules.gameSpeed;
					}
				}
				applyFriction(dt){
					this.xVel -= (this.xVel*Rules.friction)*dt*Rules.gameSpeed;
					this.yVel -= (this.yVel*Rules.friction)*dt*Rules.gameSpeed;
				}
				particleTick(){}
				tick(dt){
					this.particleTick(dt);
					if(!this.dead){
						if(this.control == "AI"){
							//this.ai(pieceList);
						}
						this.applyVelocity(dt)

						this.applyFriction(dt)

						if( !this.board.contains(this.x,this.y) && this.type != "board") {
							this.dead = true;
						}

						if(this.health < 1){
							this.dead = true;
							if(this.type == "payload" && !this.warping){
								soundBank.play("explosionBig");
								MakeParticle(this.sim, "explosion", this.x, this.y, this.xVel/3, this.yVel/3, 0)	
							}
							if(this.type == "destructible"){
								soundBank.play("explosionSmall");
							}
						}
					}
				}
			}

			class Payload extends Piece{
				constructor(sim, board, x, y){
					super("payload", board, x, y)
					this.mass = 25;
					this.width = 40;
					this.height = 40;
					this.sim = sim;
					this.hitBoxRadius = 20;
					this.blowable = true;
					this.effect = {type: "none"};
					this.health = 10;
					this.warpParticleCount = 0;
				}
				particleTick(dt){
					if(this.warping){
						this.xVel = 0;
						this.yVel = 0;
						this.warpParticleCount += 15;
					}
					for (var i = 0; i < dt*this.warpParticleCount*Rules.gameSpeed; i++) {
						MakeParticle(this.sim, "trail", this.x+((Math.random()-0.5)*40), this.y+((Math.random()-0.5)*40), 0, 0, 0)
					}
					for (var i = 0; i < dt*10*Rules.gameSpeed; i++) {
						if(Math.random()>0.95){
							MakeParticle(this.sim, "electricity", this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*20), 0, 0, 0)
						}
					}
				}
			}

			class Gate extends Piece{
				constructor(board, x, y){
					super("gate", board, x, y)
					this.width = 150;
					this.height = 150;
					this.hitBoxRadius = 7.5;
					this.blowable = false;
					this.effect = {type: "win", x: this.x, y: this.y};
				}
				/*particleTick(dt){
					let particleAngleMargin = degToRad(90)
					let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
					let velocity = 750;
					let xVel = velocity*Math.cos(particleAngle);
					let yVel = velocity*Math.sin(particleAngle);
					MakeParticle(this.sim, "force", this.x, this.y, xVel, yVel, radToDeg(particleAngle)+180)
				}*/
			}
			class Receptical extends Piece{
				constructor(sim, board, x, y){
					super("receptical", board, x, y)
					this.sim = sim;
					this.board = board;
					this.width = 170;
					this.height = 170;
					this.hitBoxRadius = 10;
					this.blowable = false;
					this.effect = {type: "attach", x: this.x, y: this.y};
					this.particleCount = 0;
				}
				particleTick(dt){
					if(this.sim.payload.attached && !this.board.earthIsOn){
						this.particleCount += 0.5;
					}
					for(var i = 0; i < dt*this.particleCount*Rules.gameSpeed; i++) {
						if(Math.random()>0.1){
							MakeParticle(this.sim, "electricity", this.x+((Math.random()-0.5)*40), this.y+((Math.random()-0.5)*40)-50, 0, 0, 0)
						}
					}

				}
			}

 			class Mine extends Piece{
				constructor(board, x, y){
					super("mine", board, x, y)
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.hitBoxRadius = 15;
					this.blowable = true;
					this.effect = {type: "damage", amount: 10};
				}
			}

			class Barricade extends Piece{
				constructor(board, x, y){
					super("barricade", board, x, y)
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 45;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Destructible extends Piece{
				constructor(board, x, y){
					super("destructible", board, x, y)
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.health = 1;
					this.collider = true;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Turret extends Piece{
				constructor(sim, board, x, y, fireDelay, bulletSpeed){
					super("turret",board, x, y)
					debug.expectNum(fireDelay, "fireDelay")
					debug.expectNum(bulletSpeed, "bulletSpeed")
					this.sim = sim;
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 50;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
					this.fireDelay = fireDelay;
					this.timeToNextFire = this.fireDelay;
					this.bulletSpeed = bulletSpeed;
					this.angle = 0;
				}
				tick(dt){
					this.particleTick(dt);
					let target = this.sim.payload;
					if(target){
						this.angle = calcAngle(this.x, this.y, target.x, target.y);
					}

					if(this.timeToNextFire <= 0){
						soundBank.play("shot");
						this.timeToNextFire = this.fireDelay;
						let velocity = this.bulletSpeed;
						let xVel = velocity*Math.cos(this.angle);
						let yVel = velocity*Math.sin(this.angle);
						this.sim.addPiece(this.x, this.y, "bullet", {type: "bullet", x: this.x, y: this.y, xVel: xVel, yVel: yVel})
					}else{
						this.timeToNextFire -= dt*Rules.gameSpeed;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.drawRotated(pieceSpec, Img.turret, camera, radToDeg(this.angle))
				}
			}
			class Bullet extends Piece{
				constructor(board, x, y, xVel, yVel){
					super("bullet", board, x, y)
					debug.expectNum(xVel, "xVel")
					debug.expectNum(yVel, "yVel")
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.xVel = xVel;
					this.yVel = yVel;
					this.hitBoxRadius = 15;
					this.blowable = true;
					this.effect = {type: "damage", amount: 10};
				}
				tick(dt){
					this.particleTick(dt);

					this.applyVelocity(dt)

					if( !this.board.contains(this.x,this.y) ) {
						this.dead = true;
					}
				}
			}
			class Text extends Piece{
				constructor(board, x, y, text, condition){
					super("text", board, x, y)
					debug.expect(text, "string", "text")
					this.hitBoxRadius = 0;
					this.board = board;
					this.text = text;
					this.condition = condition;
					this.blowable = false;
					this.effect = {type: "none"};
				}
				draw(context, camera){
					let conditionMet = false;
					if(this.condition == "power" && this.board.earthIsOn){
						conditionMet = true
					}
					if((!this.condition || conditionMet) && !Cinematic){
						let drawX = this.x-(camera.x-canvasWidth/2);
						let drawY = this.y-(camera.y-canvasHeight/2);
						context.font = "30px Arial";
						context.fillStyle = 'white';
						context.fillText(this.text, drawX, drawY);
					}
				}
			}

 			class Blower extends Piece{
				constructor(sim, board, x, y, control){
					super("blower", board, x, y, 1)
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.blowable = false;
					this.effect = {type: "none"};
					this.collider = false;

					this.sim = sim;
					this.board = board;
					this.control = control;
					this.angle = (Math.random()*Math.PI*2)-Math.PI;
					this.speed = Rules.playerSpeed;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					let angle = (this.angle/Math.PI)*180
					context.drawRotated(pieceSpec, Img.blower, camera, angle)
				}
				moveTick(dt){
					if(wDown){
						this.y -= this.speed*dt*Rules.gameSpeed;
					}
					if(sDown || this.credits){
						this.y += this.speed*dt*Rules.gameSpeed;
					}
					if(aDown || (this.credits && this.x > 0)){
						this.x -= this.speed*dt*Rules.gameSpeed;
					}
					if(dDown || (this.credits && this.x < 0)){
						this.x += this.speed*dt*Rules.gameSpeed;
					}
					[this.x,this.y] = this.board.clamp(this.x,this.y);
				}
				particleTick(dt){
					if(Rules.gameSpeed){
						MakeParticle(this.sim, "trail", this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*10), 0, 0, 0)
					}
					if(this.blowing){
						for (var i = 0; i < 100*dt*Rules.gameSpeed; i++) {
							let particleAngleMargin = degToRad(90)
							let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
							let velocity = 750;
							let xVel = velocity*Math.cos(particleAngle);
							let yVel = velocity*Math.sin(particleAngle);
							MakeParticle(this.sim, "force", this.x, this.y, xVel, yVel, radToDeg(particleAngle)+180, this)
						}
					}
				}
				ai(pieceList){
					let directionList = ["up", "down", "left", "right"]
					
				}
				tick(dt){
					this.moveTick(dt);
					this.particleTick(dt)
					if(this.health <= 0 && !this.warping){
						this.dead = true;
					}
				}
				grow(amount){
					this.length += amount*Rules.growSpeedMod*(this.speed+this.tempSpeed)/100;
				}
				speedBoost(amount){
					this.tempSpeed += amount*Rules.speedBoostMod;
				}
				strengthen(amount){
					this.strength += amount*Rules.strengthAddMod;
				}
				setTarget(x, y){
					this.angle = calcAngle(this.x, this.y, x, y);
				}
			}

			class Particle extends Piece{
				constructor(type, board, x, y, xVel, yVel, angle, parent){
					super(type, board, x, y, true)
					this.width = 5;
					this.height = 5;
					this.xVel = xVel;
					this.yVel = yVel;
					this.blowable = false;
					this.collider = false;
					this.lifeRemaining = Rules.blowRange/(xVel+yVel);
					this.angle = angle;
					if( parent ) {
						this.parent = parent;
						this.px = this.parent.x;
						this.py = this.parent.y;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					if(this.angle == 0){
						context.draw(pieceSpec, Img[this.type], camera)
					}else{
						context.drawRotated(pieceSpec, Img[this.type], camera, this.angle)
					}
				}
				tick(dt){
					if(!this.dead){
						if( this.parent ) {
							let pdx = this.parent.x - this.px;
							let pdy = this.parent.y - this.py;
							this.x += pdx;
							this.y += pdy;
							this.px = this.parent.x;
							this.py = this.parent.y;
						}

						this.applyVelocity(dt)

						this.lifeRemaining -= dt*Rules.gameSpeed;
						if(this.lifeRemaining <= 0){
							this.dead = true;
						}
					}
				}
			}
			class Force extends Particle{
				constructor(board, x, y, xVel, yVel, angle, parent){
					super("force", board, x, y, xVel, yVel, angle, parent)
					this.width = 40;
					this.height = 10;
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Trail extends Particle{
				constructor(board, x, y, xVel, yVel){
					super("trail", board, x, y, xVel, yVel)
					this.width = 5;
					this.height = 5;
					this.angle = Math.random()*360;
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Electricity extends Particle{
				constructor(board, x, y, xVel, yVel){
					super("electricity", board, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.lifeRemaining = Math.random()*0.2;
				}
			}
			class PortalEnergy extends Particle{
				constructor(board, x, y, xVel, yVel){
					super("portalEnergy", board, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.lifeRemaining = 0.5;
				}
			}
			class Explosion extends Particle{
				constructor(board, x, y, xVel, yVel){
					super("explosion", board, x, y, xVel, yVel)
					this.width = 200;
					this.height = 200;
					this.angle = 0;
					this.totalLife = 0.52;
					this.lifeRemaining = this.totalLife;
				}
				draw(context, camera){
					let frameCount = 13;
					let frame = Math.floor(((this.totalLife-this.lifeRemaining)/this.totalLife)*frameCount) //12 frames in the explosion image.
					let frameWidth = 2548/frameCount;
					let frameHeight = 190;

					let pieceSpec = {
						sx: frame*frameWidth,
						sy: 0,
						sw: frameWidth,
						sh: frameHeight,
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};

					context.draw(pieceSpec, Img[this.type], camera)
				}
			}
			function MakeParticle(sim, type, x, y, xVel, yVel, angle, parent){
				if(type == "force"){
					sim.pieceList.push(new Force(sim.board, x, y, xVel, yVel, angle, parent))
				}
				if(type == "trail"){
					sim.pieceList.push(new Trail(sim.board, x, y, xVel, yVel))
				}
				if(type == "electricity"){
					sim.pieceList.push(new Electricity(sim.board, x, y, xVel, yVel))
				}
				if(type == "portalEnergy"){
					sim.pieceList.push(new PortalEnergy(sim.board, x, y, xVel, yVel))
				}
				if(type == "explosion"){
					sim.pieceList.push(new Explosion(sim.board, x, y, xVel, yVel))
				}
			}
 			//CONTROL
 			let wDown;
 			let sDown;
			let aDown;
			let dDown;
			function initControls(sim){
				let blower = sim.pieceList[0];
				let mouseX = 0;
				let mouseY = 0;
				$( document ).on("mousemove.controls", null, function( event ) {
					mouseX = event.pageX+blower.x-canvasWidth/2;
					mouseY = event.pageY+blower.y-canvasHeight/2;
					blower.setTarget(mouseX, mouseY)
				});
				$( document ).on("mousedown.controls", null,function( event ) {
					soundBank.playLoop("repulse");
					blower.blowing = true;
				});
				$( document ).on("mouseup.controls", null, function( event ) {
					soundBank.stop("repulse");
					blower.blowing = false;
				});
				$( document ).on("keydown.controls", null, function( event ) {
					if(event.key == "w" || event.key == "W"){
						wDown = true;
					}
					if(event.key == "s" || event.key == "S"){
						sDown = true;
					}
					if(event.key == "a" || event.key == "A"){
						aDown = true;
					}
					if(event.key == "d" || event.key == "D"){
						dDown = true;
					}
					if(event.key == "Escape"){
						if(Rules.gameSpeed){
							PauseGame()
							console.log("pause")
						}else{
							UnpauseGame()
							console.log("unpause")
						}
					}
					if(level == 0){
						if(event.key == "0"){
							EditLevel(sim, levelPlan, "deletePiece")
						}
						if(event.key == "1"){
							EditLevel(sim, levelPlan, "blower", mouseX, mouseY)
						}
						if(event.key == "2"){
							EditLevel(sim, levelPlan, "gate", mouseX, mouseY)
						}
						if(event.key == "3"){
							EditLevel(sim, levelPlan, "payload", mouseX, mouseY)
						}
						if(event.key == "4"){
							EditLevel(sim, levelPlan, "barricade", mouseX, mouseY)
						}
						if(event.key == "5"){
							EditLevel(sim, levelPlan, "mine", mouseX, mouseY)
						}
						if(event.key == "6"){
							EditLevel(sim, levelPlan, "destructible", mouseX, mouseY)
						}
						if(event.key == "7"){
							EditLevel(sim, levelPlan, "turret", mouseX, mouseY)
						}
					}
				});
				$( document ).on("keyup.controls", null, function( event ) {
					if(event.key == "w" || event.key == "W"){
						wDown = false;
					}
					if(event.key == "s" || event.key == "S"){
						sDown = false;
					}
					if(event.key == "a" || event.key == "A"){
						aDown = false;
					}
					if(event.key == "d" || event.key == "D"){
						dDown = false;
					}
					
				});

			}
 			//VIEW
 			let ImageURLs = {
				blower: 'images/mover2.png',
				payload: 'images/payload.png',
				gate: 'images/gate.png',
				receptical: 'images/receptical.png',
				mine: 'images/mine.png',
				barricade: 'images/barricade.png',
				destructible: 'images/destructible.png',
				turret: 'images/turret.png',
				bullet: 'images/bullet.png',
				background: 'images/black.png',
				earthOff: 'images/earthOff.png',
				earthOn: 'images/earthOn.png',
				force: 'images/particles/force2.png',
				trail: 'images/particles/trail.png',
				electricity: 'images/particles/lightning.png',
				portalEnergy: 'images/particles/trail.png',
				explosion: 'images/explosion.png',
				star0: 'images/star0.png',
				star1: 'images/star1.png',
				star2: 'images/star2.png',
				star3: 'images/star3.png',
				star4: 'images/star4.png',
				//minimapBackground: 'images/minimapBackground.jpg',
			};
 			let Img = {};
 			class View{
				constructor(){
 				}
				
 				loadFiles(imageURLs, target, callbackFn){
					let imagesRequested = 0;
					let imagesLoaded = 0;

					soundBank = new SoundBank();
					soundBank.load("explosionBig","sound/explosionBig.mp3");
					soundBank.load("explosionSmall","sound/explosionSmall2.wav");
					soundBank.load("shot","sound/shot.wav", 0.5);
					soundBank.load("click","sound/click.mp3", 3);
					soundBank.load("charging","sound/charging.wav", 0.75);
					soundBank.load("turnOn","sound/turnOn.mp3", 4);
					soundBank.load("warpIn","sound/warpIn.wav", 3);
					soundBank.load("warpOut","sound/warpOut.wav", 5);
					soundBank.load("woosh","sound/sunDiscThrowerImpact.wav");
					soundBank.loadLoop("repulse",{
						src: "sound/repulse.wav",
						loop: true,
						volume: Rules.volume*2,
						sprite: {
							main: [0, 10000, true]
						}
					});
					soundBank.loadLoop("menuMusic",{
						src: "sound/music/ThemeMusicElectro.wav",
						loop: true,
						volume: Rules.musicVolume*10,
						sprite: {
							main: [0, 100000, true]
						}
					});
					soundBank.loadLoop("gameMusic",{
						src: "sound/music/ThemeMusicArcade.wav",
						loop: true,
						volume: Rules.musicVolume,
						sprite: {
							main: [0, 100000, true]
						}
					});
					soundBank.loadLoop("victoryMusic",{
						src: "sound/music/ThemeHeroic.mp3",
						loop: true,
						volume: Rules.musicVolume*5,
						sprite: {
							main: [0, 100000, true]
						}
					});

					for(let key in imageURLs){
						let image = imageURLs[key];
						target[key] = new Image();
						target[key].onload = function(){
							imagesLoaded ++
						};
						target[key].src = image;
						imagesRequested ++;
					}
 					let handle = setInterval( () => {
						if( imagesLoaded >= imagesRequested ) {
							console.assert(imagesLoaded == imagesRequested)
							clearInterval(handle);
							startMenuMusic()
							displayTitleScreen();
						}
					},1)
				}
 				myCanvas(canvasId, board){
					var canvas = document.getElementById(canvasId);
					var context = canvas.getContext('2d');
					context.canvas.width = window.innerWidth;
					context.canvas.height = window.innerHeight;
					
					context.draw = function(spec, imageObj, camera){
						let drawX = spec.x-(camera.x-canvasWidth/2);
						let drawY = spec.y-(camera.y-canvasHeight/2);
						if(spec.xAnchor && spec.yAnchor){
							drawX -= spec.width*spec.xAnchor;
							drawY -= spec.height*spec.yAnchor;
						}
						if(spec.sx !== undefined){
							this.drawImage(imageObj, spec.sx, spec.sy, spec.sw, spec.sh, drawX, drawY, spec.width, spec.height);
						}else{
							this.drawImage(imageObj, drawX, drawY, spec.width, spec.height);
						}
					}.bind(context)
					context.clear = function(sim){
						if( levelPlan.backgroundImg && levelPlan.backgroundImg.complete ) {
							let img = levelPlan.backgroundImg;
							let xPct = (sim.blower.x - board.xMin) / (board.size + context.canvas.width);
							let yPct = (sim.blower.y - board.yMin) / (board.size + context.canvas.height);
							let bx = img.width * 0.40 * xPct;
							let by = img.height * 0.40 * yPct;
							let bw = img.width * 0.60;
							let bh = img.height * 0.60;
							this.drawImage(img, bx, by, bw, bh, 0, 0, canvas.width, canvas.height);
						}
						else {
							let backgroundName = levelPlan.background ? (board.earthIsOn ? "earthOn" : "earthOff") : "background";
							let backgroundImg = Img[backgroundName];
							this.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
						}

						for( let i=0 ; i<window.star.length ; ++i ) {
							let star = window.star[i];
							let sx = ((star.x-sim.blower.x) * star.depth) % star.xSpan;
							let sy = ((star.y-sim.blower.y) * star.depth) % star.ySpan;
							this.drawImage(star.img,sx,sy,star.img.width,star.img.height);
						}
					
					}.bind(context)
					/*context.clearMinimap = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, 280, 260);
					}.bind(context)*/
					context.drawRotated = function(spec, imageObj, camera, degrees){
						let x = spec.x-(camera.x-canvasWidth/2);
						let y = spec.y-(camera.y-canvasHeight/2);
						x -= spec.width*spec.xAnchor;
						y -= spec.height*spec.yAnchor;
						
						let w = spec.width;
						let h = spec.height;

						this.save();
						this.translate(x+w/2, y+h/2);
						this.rotate(degrees*Math.PI/180.0);
						this.translate(-x-w/2, -y-h/2);
						this.drawImage(imageObj, x, y, w, h);
						this.restore();
					}.bind(context)
					return context
				}
 				render(context, sim){
					context.clear(sim);
 					let camera = {};
 					camera.x = sim.blower.x;
					camera.y = sim.blower.y;
					sim.pieceList.sort(function(a, b){return b.z - a.z});
 					for(let i = 0; i < sim.pieceList.length; i++){
						
						if(!sim.pieceList[i].dead){
							sim.pieceList[i].draw(context, camera)
						}
					}
				}
/*				renderMinimap(context, sim){
					context.clearMinimap()
					
					let camera = {};
 					camera.x = 100;
					camera.y = 100;

					let boardSizeMod = (sim.board.size/2000)

 					for(let i = 0; i < sim.pieceList.length; i++){
						let pieceSpec = {x: sim.pieceList[i].x/10, y: sim.pieceList[i].y/10, width: (sim.pieceList[i].width/10)/boardSizeMod, height: (sim.pieceList[i].height/10)/boardSizeMod, xAnchor: 0.5, yAnchor: 0.5};
						
						let drawX = (pieceSpec.x+(120*boardSizeMod))/boardSizeMod;
						let drawY = (pieceSpec.y+(130*boardSizeMod))/boardSizeMod;
						
						if(pieceSpec.xAnchor && pieceSpec.yAnchor){
							drawX -= pieceSpec.width*pieceSpec.xAnchor;
							drawY -= pieceSpec.height*pieceSpec.yAnchor;
						}

						if(!sim.pieceList[i].dead){
							context.drawImage(Img[sim.pieceList[i].type], drawX, drawY, pieceSpec.width, pieceSpec.height);
						}
					}

					let blowerSpec = {x: sim.pieceList[0].x/10, y: sim.pieceList[0].y/10, width: 10, height: 10, xAnchor: 0.5, yAnchor: 0.5};

					let drawX = (blowerSpec.x+(120*boardSizeMod))/boardSizeMod;
					let drawY = (blowerSpec.y+(130*boardSizeMod))/boardSizeMod;
					
					if(blowerSpec.xAnchor && blowerSpec.yAnchor){
						drawX -= blowerSpec.width*blowerSpec.xAnchor;
						drawY -= blowerSpec.height*blowerSpec.yAnchor;
					}
					context.drawImage(Img.blower, drawX, drawY, blowerSpec.width, blowerSpec.height);
					
				}*/
			}
 			//ORGANIZATION
			function displayTitleScreen(){
				$("#canvas").hide()
				$("#brief").hide()
				$("#gameOverScreen").hide()
				$("#levelSelect").hide()
				$("#titleScreen").show()
			}
			function displayLevelSelect(){
				$("#gameOverScreen").hide()
				$("#titleScreen").hide()
				$("#levelSelect").show()
				$("#levelSelect").empty();
				for (let i = 1; i < LevelList.length; i++) {
					if(i <= Rules.demoLevelLimit || !Rules.isDemo){
						$("#levelSelect").append('<button class="menuButton levelButton" onClick="level = '+i+'; levelPlan = LevelList[level]; startGameMusic(); Main()">'+i+'</button>');
					}
					if(i%10 == 0){
						$("#levelSelect").append('<br>');
					}
				}
				$("#levelSelect").prepend('<h1 class="menuTitle">Choose A Level</h1>')
				$("#levelSelect").append('<br> </br> <button class="menuButton" onClick="level = 0; levelPlan = LevelList[0]; Main()">Level Builder</button> <br> </br> <button class="menuButton" onClick="displayTitleScreen()">Back</button>');
			}
			function displayGameOverScreen(win, startTime){
				debug.assert(!handleView);
				$("#canvas").hide()
				$("#levelSelect").hide()
				$("#menus").show()
				$("#gameOverScreen").show()
				$("#gameOverScreen").empty();
				if(win){
					let time = Math.floor((Date.now()-startTime)/100)/10; //this is to get just 1 decimal point of detail.
					$("#gameOverScreen").html('<h1 class="menuTitle">You Win!</h1> <div class="menuText">Level '+level+' completed in '+time+' seconds!</div> <button class="menuButton" onClick="startMenuMusic(); displayTitleScreen()">Main Menu</button> <button class="menuButton" onClick="level = '+level+'; levelPlan = LevelList[level]; Main()">Play Again</button> <button id="nextLevelButton" class="menuButton" onClick="level = '+(level+1)+'; levelPlan = LevelList[level]; Main()">Next Level</button>');
					if(level == Rules.demoLevelLimit && Rules.isDemo){
						$("#nextLevelButton").hide()
					}
				}else{
					$("#gameOverScreen").html('<h1 class="menuTitle">You Lose!</h1> <button class="menuButton" onClick="startMenuMusic(); displayTitleScreen()">Main Menu</button> <button class="menuButton" onClick="level = '+level+'; levelPlan = LevelList[level]; Main()">Try Again</button>');
				}
			}
			function displayBrief(){
				$("#titleScreen").hide()
				$("#brief").show()
			}
 			function GameOver(){
				debug.assert(handleView);
 				soundBank.stop("repulse");
 				$(document).off(".controls")
 				window.animateView = false;
 				cancelAnimationFrame(handleView)
 				handleView = null;
			}
			function startGameMusic(){
				soundBank.stopAll();
				soundBank.playLoop("gameMusic");
			}
			function startMenuMusic(){
				soundBank.stopAll();
				soundBank.playLoop("menuMusic");
			}
			function PauseGame(){
				Rules.gameSpeed = 0;
				$("#restartLevelButton").click(
					()=>{
						GameOver();
						levelPlan = LevelList[level];
						Main();
					}
				)
				$("#pauseMenuOuter").show()
			}
			function UnpauseGame(){
				Rules.gameSpeed = 0.5;
				$("#pauseMenuOuter").hide()
			}

 			function Main(){
 				soundBank.play("warpIn")
 				let startTime = Date.now();
				UnpauseGame()
				//level = prompt("Which level would you like to play?");
				wDown = false;
				sDown = false;
				aDown = false;
				dDown = false;

				$("#menus").hide()
				$("#canvas").show()
				let levelPlan = LevelList[level];
				let view = new View();
				let board = new Board(levelPlan.boardSize || Rules.boardSize);
				let context = view.myCanvas('canvas', board);
				let sim = new Sim(board);
				initControls(sim);
				if( levelPlan.backgroundUrl ) {
					levelPlan.backgroundImg = new Image();
					levelPlan.backgroundImg.src = levelPlan.backgroundUrl;
				}
				
				function tickSim(){
					let levelPlan = LevelList[level]
					if( !sim.gameFailLatch && !sim.payload){
						sim.gameFailLatch = true;
						setTimeout(() => {
							GameOver()
							displayGameOverScreen(false)
						},2000)
					}

					sim.timeSinceLastSim = 0;
					let dt;
					let now = Date.now();
					if(sim.nowPrior === null){
						dt = 1.0/FPS;
					}else{
						dt = (now - sim.nowPrior)/1000;
					}
					sim.nowPrior = now;
					sim.timeSinceLastSim += dt;
					while(sim.timeSinceLastSim > 1/FPS){
						sim.piecesBlown(dt);
						if(sim.piecesTouched() == "next level"){
							return "next level"
						}
						sim.tick(1/FPS);
						sim.timeSinceLastSim -= 1/FPS;
					}
				}
 				function tickView(){
					view.render(context, sim);
					//view.renderMinimap(context, sim);
				}

				$("#titleScreen").hide()

				let avLatch = false;
				function animateView(){
					tickView()
					if(tickSim() == "next level" && !avLatch ){
						avLatch = true;
						setTimeout(
							()=>{
								soundBank.play("woosh")
								GameOver()
								displayGameOverScreen(true, startTime)
							}, 4000
						)
					}
					handleView = requestAnimationFrame( animateView );
				}
				debug.assert( !window.animateView );
				window.animateView = true;
 				animateView();
			}

			function onResize() {
				let canvasId = "canvas"
				let canvas = document.getElementById(canvasId);
				if( !canvas ) return;
				let context = canvas.getContext('2d');
				if( !context ) return;
				context.canvas.width = window.innerWidth;
				context.canvas.height = window.innerHeight;
 				canvasWidth = $("#canvas").width();
				canvasHeight = $("#canvas").height();
				console.assert(canvasWidth > 0)
				console.assert(canvasHeight > 0)
				MakeStars(context);
			}

			$(document).ready(function(){
				if(Cinematic){
					document.getElementById("canvas").style.cursor = "none";
				}

				let view = new View();
				view.loadFiles(ImageURLs, Img, Main);
				onResize();
				
				$(window).resize( onResize );
			});
			
	</script>
  </body>
</html>		
		</script>
	</head>
	<body>
		<div id="menus" class="ctr">
			<div id="titleScreen" class="menu">
				<h1 class="menuTitle">
					Reactor Rescue
				</h1>
				<button class="bigMenuButton" onClick="level = 1; levelPlan = LevelList[level]; startGameMusic(); Main()">
					Play
				</button>
				<br>
				<button class="menuButton" onClick="displayBrief()">
					Briefing
				</button>
				<button class="menuButton" onClick="displayLevelSelect()">
					Level Select
				</button>
			</div>
			<div id="brief" class="menu">
				<h1 class="menuTitle">
					Your Mission
				</h1>
				<div class="menuText">
					<p>
						The enemy has stolen the Quantum Arc-Reactor and placed it deep behind enemy lines.
						You must get it back to High Command.
					</p>
					<p>
						We can warp you to the Arc-Reactor.
						Use your repulser to push it through the blue warp gates. They will lead you back to High Command.
					</p>
					<p>
						However, the Arc-Reactor is unstable!
						If it touches anything, it will go critical and our most valuable asset will be destroyed.
						This is why you must get it back to us with only your repulser field.
					</p>
					<p>
						Good Luck, Captain.
					</p>
				</div>
				<button class="menuButton" onClick="displayTitleScreen()">
					Understood
				</button>
			</div>
			<div id="levelSelect" class="menu">
				<h1 class="menuTitle">
					Choose A Level
				</h1>
			</div>
			<div id="gameOverScreen" class="menu">
			</div>
		</div>
		<div id="canvasDiv" width="100%" height="100%">
			<div id="pauseMenuOuter">
				<div id="pauseMenu">
					<h1 class="menuTitle pauseMenuTitle">
						Game Paused
					</h1>
					<div class="ctr">
						<button class="menuButton" onclick="UnpauseGame()">
							Resume Game
						</button>
						<button class="menuButton" id="restartLevelButton">
							Restart Level
						</button>
						<button class="menuButton" onclick="GameOver(); displayGameOverScreen(true, 0); startMenuMusic(); displayTitleScreen();">
							Main Menu
						</button>
					</div>
				</div>
			</div>
			<canvas id="canvas" width="100%" height="100%"></canvas>
		</div>
	</body>
</html>