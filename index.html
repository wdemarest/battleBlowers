<html>
	<head>
		<style type="text/css">
			#canvas{
				width: 100%;
				height: 120%;
				cursor: crosshair;
			}
			#titleScreen{
				margin-left: 100;
			}
			.levelButton{
				font-size: 500%;
			}
			#title{
				font-size: 500%;
			}
			#playButton{
				width: 100px;
       			height: 50px;
			}
		</style>
		<title> Blower Game </title>
		<link rel="stylesheet" type="text/css" href="minireset.css">
		<script
  src="https://code.jquery.com/jquery-3.3.1.js"
  integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
  crossorigin="anonymous"></script>
  <script src="levels.js" charset="utf-8"></script>
		<script>
			/*
				
			*/
			let Rules = {boardSize: 2000}
			let FPS = 60;
			

			let ruleSets = {
				normal: {
					blowerCount: 5,
					bombDensity: (0.1),
					blockDensity: 0.01,
					speedMod: 3,
					blowRange: 200,
					blowForce: 100,
				}
			}

			let canvasWidth;
			let canvasHeight;

			let LevelList = MakeLevelList();

 			let level;

 			let levelPlan;

			Rules = Object.assign(Rules, ruleSets.normal)


 			function degToRad(deg){
				return deg/180*Math.PI;
			}
			/*
			function normalizeRads(rad){
				while(Math.abs(rad) > Math.PI){
					if(rad > 0){
						rad -= Math.PI*2;
					}else{
						rad += Math.PI*2;
					}
				}
				return rad;
			}
			*/
			function calcDist(x1, y1, x2, y2){
				let dx = (x1-x2);
				let dy = (y1-y2);
				return Math.abs(Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2)))
			}
			function pickRandom(list){
				let seed = Math.floor(Math.random()*list.length);
				return list[seed]
			}
			function calcAngle(x1, y1, x2, y2){
				let dx = (x2-x1);
				let dy = (y2-y1);
				let rad = Math.atan2(dy,dx)
				return rad;
			}
			class Board{
				constructor(size){
					this.size = size;
				}
				pickRandomLocation(){
					return Math.random()*this.size-(this.size/2)
				}
			}
 			class Sim{
 				constructor(board){
 					this.pieceList = [];
					
					this.addPiece = (x, y, type) => {
 						if(type == "blower"){
							return this.pieceList.push(new Blower(board, x, y))
						}
 						if(type == "payload"){
							return this.pieceList.push(new Payload(board, x, y))
						}
						if(type == "destination"){
							return this.pieceList.push(new Destination(board, x, y))
						}
						if(type == "bomb"){
							return this.pieceList.push(new Bomb(board, x, y))
						}
						if(type == "block"){
							return this.pieceList.push(new Block(board, x, y))
						}
					}
					this.nowPrior = null;
 					this.board = board;

 					for (let i = 0; i < levelPlan.length; i++) {
 						let object = levelPlan[i];
					
						this.addPiece(object.x, object.y, object.type)
					}

					this.blower = this.pieceList[0];

 					/*
 					for (let i = 0; i < Rules.blowerCount; i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
					
						this.blowerList.push (new Blower(board, x, y, "AI"));
					}
 					this.blower = this.blowerList[0];
 					this.pieceList = [];
 					for (let i = 0; i < (1); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "payload")
					}
					for (let i = 0; i < (1); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "destination")
					}
					for (let i = 0; i < (Rules.bombDensity*(board.size^2)); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "bomb")
					}
					for (let i = 0; i < (Rules.blockDensity*(board.size^2)); i++) {
						let x = board.pickRandomLocation();
						let y = board.pickRandomLocation();
						this.addPiece(x, y, "block")
					}
					*/
 				}
 				tick(dt){
					this.pieceList.forEach(piece => piece.tick(dt))
				}
 				piecesBlown(dt){
					if(this.pieceList[0].blowing){
						let blower = this.pieceList[0];
						for(let i = 0; i < this.pieceList.length; i++){
							let piece = this.pieceList[i];
							if(!piece.blowAble){
								continue;
							}
							let angle = calcAngle(blower.x, blower.y, piece.x, piece.y);
							let blowArc = degToRad(45);
							let dist = calcDist(blower.x, blower.y, piece.x, piece.y);
							if(blower.pointingRad < angle+blowArc && blower.pointingRad > angle-blowArc && dist < Rules.blowRange){
								let velIncrease = (((Rules.blowRange-calcDist(blower.x, blower.y, piece.x, piece.y))*Rules.blowForce)/piece.mass)*dt;
								piece.xVel -= velIncrease*((blower.x - piece.x)/dist)
								piece.yVel -= velIncrease*((blower.y - piece.y)/dist)
								piece.lit = true;
							}else{
								piece.lit = false;
							}
						}
					}
				}
 				piecesTouched(){
 					let nextLevel = false;
					this.pieceList.forEach(piece => {
						if(piece.dead){
							return;
						}
						for(let i = 0; i < this.pieceList.length; i++){
							let piece2 = this.pieceList[i];
							if(calcDist(piece.x, piece.y, piece2.x, piece2.y) < (piece.hitBoxRadius+piece2.hitBoxRadius)){
								if(piece.applyEffect(piece2.effect) == "next level"){
									nextLevel = true;
								}
							}
						}
					})
					if(nextLevel){
						return "next level"
					}
				}
			}
			class Piece{
				constructor(board, x, y){
					this.board = board;
					this.x = x;
					this.y = y;
					this.xVel = 0;
					this.yVel = 0;
					this.type;
					this.mass = 1;
					this.width;
					this.height;
					this.radius;
					this.effect;
				}
				applyEffect(effect){
					if(effect.type == "damage"){
						this.health -= effect.amount;
					}
					if(effect.type == "win" && this.type == "destination"){
						this.dead = true;
						return "next level";
					}
				}
				tick(dt){
					if(!this.dead){
						if(this.control == "AI"){
							//this.ai(pieceList);
						}
						this.x += this.xVel*dt;
						this.y += this.yVel*dt;

						this.xVel -= (this.xVel*0.01)*dt;
						this.yVel -= (this.yVel*0.01)*dt;

						if(this.x > this.board.size/2){
							this.x -= this.board.size;
						}
						if(this.x < -this.board.size/2){
							this.x += this.board.size;
						}
						if(this.y > this.board.size/2){
							this.y -= this.board.size;
						}
						if(this.y < -this.board.size/2){
							this.y += this.board.size;
						}
						if(this.health < 1){
							this.dead = true;
						}
					}
				}
			}

			class Payload extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "payload";
					this.mass = 25;
					this.width = 40;
					this.height = 40;
					this.hitBoxRadius = 20;
					this.blowAble = true;
					this.effect = {type: "win", amount: 10};
					this.health = 10;
				}
			}

			class Destination extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "destination";
					this.width = 150;
					this.height = 150;
					this.hitBoxRadius = 5;
					this.blowAble = false;
					this.effect = {type: "none"};
				}
			}

 			class Bomb extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "bomb";
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.hitBoxRadius = 15;
					this.blowAble = true;
					this.effect = {type: "damage", amount: 1};
				}
			}

			class Block extends Piece{
				constructor(board, x, y){
					super(board, x, y)
					this.type = "block";
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 50;
					this.blowAble = false;
					this.effect = {type: "damage", amount: 10};
				}
			}

 			class Blower extends Piece{
				constructor(board, x, y, control){
					super(board, x, y)
					this.type = "blower";
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.blowAble = false;
					this.effect = {type: "none"};

					this.board = board;
					this.control = control;
					this.pointingRad = (Math.random()*Math.PI*2)-Math.PI;
					this.speed = 500;
					this.air = 100;
				}
				moveTick(dt){
					if(wDown){
						this.y -= this.speed*dt;
						console.assert( !isNaN(this.y) );
					}
					if(sDown){
						this.y += this.speed*dt;
						console.assert( !isNaN(this.y) );
					}
					if(aDown){
						this.x -= this.speed*dt;
					}
					if(dDown){
						this.x += this.speed*dt;
					}
				}
				airTick(dt){
					if(!this.blowing && this.air < 100){
						this.air += dt;
					}
					if(this.blowing){
						this.air -= 2*dt;
					}
					if(this.air <= 0){
						this.blowing = false;
					}
				}
				ai(pieceList){
					let directionList = ["up", "down", "left", "right"]
					//if(Math.random() > 0.999){
					//	this.direction = directionList[Math.floor(Math.random()*4)]
					//}
					
				}
				tick(dt){
					if(this.control == "AI"){
						//this.ai(pieceList);
					}
					this.moveTick(dt);
					this.airTick(dt)
					if(this.health <= 0 ){
						this.dead = true;
					}
				}
				grow(amount){
					this.length += amount*Rules.growSpeedMod*(this.speed+this.tempSpeed)/100;
				}
				speedBoost(amount){
					this.tempSpeed += amount*Rules.speedBoostMod;
				}
				strengthen(amount){
					this.strength += amount*Rules.strengthAddMod;
				}
				setTarget(x, y){
					this.pointingRad = calcAngle(this.x, this.y, x, y);
				}
			}
 			//CONTROL
 			let wDown;
 			let sDown;
			let aDown;
			let dDown;
			function initControls(sim){
				let blower = sim.pieceList[0];
				let mouseX = 0;
				let mouseY = 0;
				$( document ).mousemove(function( event ) {
					mouseX = event.pageX+blower.x-canvasWidth/2;
					mouseY = event.pageY+blower.y-canvasHeight/2;
					blower.setTarget(mouseX, mouseY)
				});
				$( document ).mousedown(function( event ) {
					blower.blowing = true;
				});
				$( document ).mouseup(function( event ) {
					blower.blowing = false;
				});
				$( document ).keydown(function( event ) {
					if(event.key == "w"){
						wDown = true;
					}
					if(event.key == "s"){
						sDown = true;
					}
					if(event.key == "a"){
						aDown = true;
					}
					if(event.key == "d"){
						dDown = true;
					}
					if(level == 0){
						if(event.key == "0"){
							EditLevel(sim, levelPlan, "deletePiece")
						}
						if(event.key == "1"){
							EditLevel(sim, levelPlan, "blower", mouseX, mouseY)
						}
						if(event.key == "2"){
							EditLevel(sim, levelPlan, "destination", mouseX, mouseY)
						}
						if(event.key == "3"){
							EditLevel(sim, levelPlan, "payload", mouseX, mouseY)
						}
						if(event.key == "4"){
							EditLevel(sim, levelPlan, "block", mouseX, mouseY)
						}
						if(event.key == "5"){
							EditLevel(sim, levelPlan, "bomb", mouseX, mouseY)
						}
					}
				});
				$( document ).keyup(function( event ) {
					if(event.key == "w"){
						wDown = false;
					}
					if(event.key == "s"){
						sDown = false;
					}
					if(event.key == "a"){
						aDown = false;
					}
					if(event.key == "d"){
						dDown = false;
					}
					
				});

			}
 			//VIEW
 			let ImageURLs = {
				blower: 'images/mover.png',
				payload: 'images/payload.png',
				destination: 'images/gate.png',
				bomb: 'images/mine.png',
				block: 'images/block.png',
				//wind: 'images/wind2.png',
				background: 'images/black.png',
				//minimapBackground: 'images/minimapBackground.jpg',
			};
 			let Img = {};
 			class View{
				constructor(){
 				}
				
 				imageLoad(imageURLs, target, callbackFn){
					let imagesRequested = 0;
					let imagesLoaded = 0;
					for(let key in imageURLs){
						let image = imageURLs[key];
						target[key] = new Image();
						target[key].onload = function(){
							imagesLoaded ++
						};
						target[key].src = image;
						imagesRequested ++;
					}
 					let handle = setInterval( () => {
						if( imagesLoaded >= imagesRequested ) {
							console.assert(imagesLoaded == imagesRequested)
							clearInterval(handle);
							displayLevelSelect();
						}
					},1)
				}
 				myCanvas(canvasId, board){
					var canvas = document.getElementById(canvasId);
					var context = canvas.getContext('2d');
					
					context.draw = function(spec, imageObj, camera){
						let drawX = spec.x-(camera.x-canvasWidth/2);
						let drawY = spec.y-(camera.y-canvasHeight/2);
						if(spec.xAnchor && spec.yAnchor){
							drawX -= spec.width*spec.xAnchor;
							drawY -= spec.height*spec.yAnchor;
						}
						this.drawImage(imageObj, drawX, drawY, spec.width, spec.height);
					}.bind(context)
 					context.clear = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, canvas.width, canvas.height);
					}.bind(context)
					context.clearMinimap = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, 280, 260);
					}.bind(context)
					context.drawRotated = function(spec, imageObj, camera, degrees){
						let x = spec.x-(camera.x-canvasWidth/2);
						let y = spec.y-(camera.y-canvasHeight/2);
						x -= spec.width*spec.xAnchor;
						y -= spec.height*spec.yAnchor;
						
						let w = spec.width;
						let h = spec.height;

						this.save();
						this.translate(x+w/2, y+h/2);
						this.rotate(degrees*Math.PI/180.0);
						this.translate(-x-w/2, -y-h/2);
						this.drawImage(imageObj, x, y, w, h);
						this.restore();
					}.bind(context)
					return context
				}
 				render(context, sim){
					context.clear();
 					let camera = {};
 					camera.x = sim.blower.x;
					camera.y = sim.blower.y;
 					for(let i = 0; i < sim.pieceList.length; i++){
						let pieceSpec = {
							x: sim.pieceList[i].x,
							y: sim.pieceList[i].y,
							width: sim.pieceList[i].width,
							height: sim.pieceList[i].height,
							xAnchor: 0.5,
							yAnchor: 0.5
						};
						
						if(!sim.pieceList[i].dead){
							if(sim.pieceList[i].type == "blower"){
								let angle = (sim.pieceList[i].pointingRad/Math.PI)*180
								context.drawRotated(pieceSpec, Img[sim.pieceList[i].type], camera, angle)
							}else{
								context.draw(pieceSpec, Img[sim.pieceList[i].type], camera)
							}
						}
					}
				}
				renderMinimap(context, sim){
					context.clearMinimap()
					
					let camera = {};
 					camera.x = 100;
					camera.y = 100;

					let boardSizeMod = (sim.board.size/2000)

 					for(let i = 0; i < sim.pieceList.length; i++){
						let pieceSpec = {x: sim.pieceList[i].x/10, y: sim.pieceList[i].y/10, width: (sim.pieceList[i].width/10)/boardSizeMod, height: (sim.pieceList[i].height/10)/boardSizeMod, xAnchor: 0.5, yAnchor: 0.5};
						
						let drawX = (pieceSpec.x+(120*boardSizeMod))/boardSizeMod;
						let drawY = (pieceSpec.y+(130*boardSizeMod))/boardSizeMod;
						
						if(pieceSpec.xAnchor && pieceSpec.yAnchor){
							drawX -= pieceSpec.width*pieceSpec.xAnchor;
							drawY -= pieceSpec.height*pieceSpec.yAnchor;
						}

						if(!sim.pieceList[i].dead){
							context.drawImage(Img[sim.pieceList[i].type], drawX, drawY, pieceSpec.width, pieceSpec.height);
						}
					}

					let blowerSpec = {x: sim.pieceList[0].x/10, y: sim.pieceList[0].y/10, width: 10, height: 10, xAnchor: 0.5, yAnchor: 0.5};

					let drawX = (blowerSpec.x+(120*boardSizeMod))/boardSizeMod;
					let drawY = (blowerSpec.y+(130*boardSizeMod))/boardSizeMod;
					
					if(blowerSpec.xAnchor && blowerSpec.yAnchor){
						drawX -= blowerSpec.width*blowerSpec.xAnchor;
						drawY -= blowerSpec.height*blowerSpec.yAnchor;
					}
					context.drawImage(Img.blower, drawX, drawY, blowerSpec.width, blowerSpec.height);
					
				}
			}
 			//ORGANIZATION
 			function displayLevelSelect(){
 				$("#canvas").hide()
 				$("#titleScreen").show()
 				$("#levelSelect").html('');
 				for (let i = 1; i < LevelList.length; i++) {
 					$("#levelSelect").append('<button class="levelButton" onClick="level = '+i+'; levelPlan = LevelList[level]; Main()">'+i+'</button>');
 				}
 				$("#levelSelect").append('<br></br> <button class="levelButton" onClick="level = 0; levelPlan = LevelList[0]; Main()">Level Builder</button>');
 			}

 			function GameOver(sim, handleSim, handleView){
 				cancelAnimationFrame(handleView)
 				displayLevelSelect()
			}

 			function Main(){
 				//level = prompt("Which level would you like to play?");
				wDown = false;
	 			sDown = false;
				aDown = false;
				dDown = false;
 

 				$("#playAgain").hide()
				$("#canvas").show()
				let view = new View();
 				let board = new Board(Rules.boardSize);
 				let context = view.myCanvas('myCanvas', board);
 				let sim = new Sim(board);
 				initControls(sim);
 				function tickSim(){
 					let levelPlan = LevelList[level]
 					if(levelPlan[2].dead){
 						GameOver(sim, handleSim, handleView)
 					}

					sim.timeSinceLastSim = 0;
					let dt;
					let now = Date.now();
					if(sim.nowPrior === null){
						dt = 1.0/FPS;
					}else{
						dt = (now - sim.nowPrior)/1000;
					}
					sim.nowPrior = now;
					sim.timeSinceLastSim += dt;
					while(sim.timeSinceLastSim > 1/FPS){
						sim.piecesBlown(dt);
						if(sim.piecesTouched() == "next level"){
							return "next level"
						}
						sim.tick(1/FPS);
						sim.timeSinceLastSim -= 1/FPS;
					}
				}
 				function tickView(){
					view.render(context, sim);
					view.renderMinimap(context, sim);
				}

				$("#titleScreen").hide()

				let tickBoth = function() {
					//tickView();
				}

				let handleView;
				function animateView(){
					tickView()
					handleView = requestAnimationFrame( animateView );
					if(tickSim() == "next level"){
						GameOver()
					}
				}
 				animateView();
			}

 			$( document ).ready(function(){	
 				$("#titleScreen").hide() //temporary for dev
 				
 				canvasWidth = $("#canvas").width();
				canvasHeight = $("#canvas").height();
				console.assert(canvasWidth > 0)
				console.assert(canvasHeight > 0)

				let view = new View();
				view.imageLoad(ImageURLs, Img, Main);
			});
			
			//art by: eleksey goldis
    </script>
  </body>
</html>        
		</script>
	</head>
	<body>
		<div id="titleScreen">
			<h1 id="title">
				Blower Game
			</h1>
			<div id="levelSelect">
			</div>
			<pre id="leaderBoard">

			</pre>
		</div>
		<div id="canvas">
			<canvas id="myCanvas" width="1000" height="790"></canvas>
		</div>
	</body>
</html>