<html>
	<head>
		<link rel="stylesheet" type="text/css" href="minireset.css">
		<style type="text/css">
			html, body{
				height: 100%;
				overflow: hidden;
			}
			body {
				color: rgb(220, 220, 220);
				background-color: #061319;
			}

			#canvas{
				width: 100%;
				height: 100%;
				cursor: crosshair;
			}
			#menus{
				border: 1px solid black;
				height: 100%;
				min-width: 1024px;
			}
			#menuBg{
				z-index: -1;
				width: 100%;
				min-width: 1024px;
				height: 100%;
				position: absolute;
			}
			.menu{
				margin-left: 15%;
				margin-right: 20%;
				margin-top: 6%;
			}
			.show{
				display: block;
			}
			.hide{
				display: none;
			}
			.mainTitle{
				font-size: 500%;
				font-family: "impact";
			}
			#overlayMenu{
				display: none;
				background-color: rgba(0, 0, 0, 0.75);
				z-index: 10;
				position: absolute;
				width: 100%;
				height: 100%;
				align-items: center;
			}
			#pauseMenu, #gameOverScreen{
				border: 1px solid #537b80;
				background-color: rgba(54, 178, 262, 0.25);
				z-index: 11;
				margin-left: auto;
				margin-right: auto;
				width: 800;
				padding: 32px;
				margin-top: 50px;
			}
			.timeTable tr td {
				padding-right: 8px;
			}
			.ctr{
				text-align: center;
			}
			.ctrMargin{
				margin-left: auto;
				margin-right: auto;
			}
			.right{
				text-align: right;
			}
			.pauseMenuTitle{
				text-align: center;
 				margin-bottom: 32px;
			}
			.menuTitle{
				font-size: 500%;
				font-family: "impact";
				color: rgb(6, 17, 22);
				text-shadow:
					-1px -1px 0 #acbccc,
					1px -1px 0 #acbccc,
					-1px 1px 0 #acbccc,
					1px 1px 0 #acbccc;
			}
			.menuText{
				font-size: 150%;
				font-family: "courier";
			}
			.menuText p{
				padding-bottom: 20px;
				color: rgb(220, 220, 220);
			}
			.menuButton, .bigMenuButton{
				width: 235px;
				font-size: 200%;
				font-family: "Arial";
				border-radius: 10px;
				color: rgb(220, 220, 220);
				background-color: rgba(0, 0, 0, 0);
				margin-top: 2px;
				margin-bottom: 2px;
				border: 1px solid rgb(220, 220, 220);
			}
			.menuButton:hover, .bigMenuButton:hover{
				margin-top: 1px;
				margin-bottom: 1px;
				border: 2px solid white;
			}
			.levelButton{
				margin-left: 2px;
				margin-right: 2px;
				width: 60px;
				text-align: center;
			}
			.levelDisable{
				background-color: rgba(105,105,105,0.4);
				color: rgb(150,150,150,0.6);
				border: 1px solid rgb(150,150,150,0.6);
			}
			.levelDisable:hover{
				margin-top: 2px;
				margin-bottom: 2px;
				border: 1px solid rgb(150,150,150,0.6);
			}
			.bigMenuButton{
				font-size: 300%;
			}
			#playButton{
				width: 100px;
	   			height: 50px;
			}
			.spacer {
				margin: 0px;
				padding: 0px;
				height: 24px;
			}
			.spacer2x {
				margin: 0px;
				padding: 0px;
				height: 48px;
			}
			#demoNote {
				position: absolute;
				top: 0px;
				width:100%;
			}
			#demoNote div {
				background-color: black;
				color: gray;
				float: right;
			}
			@media (max-width: 1336px) {
				.menuTitle {
					font-size: 300%;
				}
				.menuText{
					font-size: 18px;
				}
				.menuButton{
					font-size: 150%;
				}
			}
			@media (min-width: 1131px) and (max-width: 1336px) {
				.menuTitle {
					font-size: 400%;
				}
				.menuText{
					font-size: 20px;
				}
				.menuButton{
					font-size: 175%;
				}
			}
		</style>
		<title>Reactor Rescue</title>
		<script
			src="https://code.jquery.com/jquery-3.3.1.js"
			integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
			crossorigin="anonymous">
		</script>
		<script src="levels.js" charset="utf-8"></script>
		<script src="debug.js" charset="utf-8"></script>
		<script src="howler2.js" charset="utf-8"></script>
		<script>
			let Rules = {boardSize: 2000}
			let FPS = 60;
			let counter = 0;
			

			let ruleSet = {
				speedMod: 3,
				blowRange: 200,
				blowForce: 100,
				friction: 1,
				minSpeed: 1,
				playerSpeed: 500,
				gameSpeed: 0,
				volume: 0.1,
				musicVolume: 0.03,
				isDemo: false,
				showLevelBuilder: false,
				demoLevelLimit: 8,
				zOrders: {text: -1, particle: 0, blower: 1, payload: 2, bullet: 3, mine: 4, destructible: 5, turret: 6, barricade: 7, gate: 8, receptical: 8}
			};

			let canvasWidth;
			let canvasHeight;
			let handleView;
			let handleInterval;

			let Cinematic = false;

 			let debug = new Debug;

			Rules = Object.assign(Rules, ruleSet);
			let Records = {
				you: [],
				best: [],
			};

			function timeReadable(elapsedTime) {
				let s = ''+Math.floor(elapsedTime*10)/10;
				if( s.indexOf('.')<0 ) {
					s += '.0';
				}
				return s;
			}

			function SoundBank(){
				var list = [];
				var handle = {};
				this.load = function(name, src, volume) {
					list[name] = new Howl({
						src: [src],
						volume: (volume || 1.0)*Rules.volume
					});
				};
				this.loadLoop = function(name, params) {
					list[name] = new Howl(params);
				};
				this.play = function(name) {
					handle[name] = list[name].play();
					return handle[name];
				};
				this.playLoop = function(name) {
					handle[name] = list[name].play("main");
					return handle[name];
				};
				this.stop = function(name) {
					if( handle[name] ) {
						list[name].stop(handle[name]);
					}
				};
				this.stopAll = function() {
					for( var name in list ) {
						this.stop(name);
					}
				}
				return this;
			}
			let soundBank = new SoundBank;
			$(document).on('click',".menuButton", function(){
				soundBank.play("click");
			});
			function degToRad(deg){
				return (deg/180*Math.PI);
			}
			function radToDeg(rad){
				return (rad/Math.PI*180)+180;
			}
			/*
			function normalizeRads(rad){
				while(Math.abs(rad) > Math.PI){
					if(rad > 0){
						rad -= Math.PI*2;
					}else{
						rad += Math.PI*2;
					}
				}
				return rad;
			}
			*/
			function randInt(max) {
				return Math.floor(Math.random()*max);
			}

			function calcDist(x1, y1, x2, y2){
				let dx = (x1-x2);
				let dy = (y1-y2);
				return Math.abs(Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2)))
			}
			function pickRandom(list){
				let seed = randInt(list.length);
				return list[seed]
			}
			function calcAngle(x1, y1, x2, y2){
				let dx = (x2-x1);
				let dy = (y2-y1);
				let rad = Math.atan2(dy,dx)
				return rad;
			}
			function isWithinArc(sourceRad, targetRad, arc){
				let a0 = sourceRad;
				let a1 = sourceRad - Math.PI*2;
				let a2 = sourceRad + Math.PI*2;
				let min = targetRad - arc;
				let max = targetRad + arc;

				if(
					(a0 >= min && a0 <= max) ||
					(a1 >= min && a1 <= max) ||
					(a2 >= min && a2 <= max)
				){
					return true;
				}
				return false;
			}


			var Internet = function() {
				var attempt = {};
				var counter = 0;

				function isEmpty(obj) {
				    for(var prop in obj) {
				        if(obj.hasOwnProperty(prop))
				            return false;
				    }
				    return true;
				}
				
				this.retry = function() {
					for( var handle in attempt ) {
						attempt[handle]();
					}
				}
				function clear(handle) {
					delete attempt[handle];
					if( isEmpty(attempt) ) {
						$('#internetDown').hide();
					}
				}
				function error(j, textStatus, errorThrown) {
					if( j.status == 0 ) {
						$('#internetDown').show();
					}
					else {
						alert(textStatus, errorThrown);
					}
				}
				this.ajax = function(_spec,callback) {
					var handle = counter++;
					var spec = $.extend(true,{},_spec);
					spec.timeout = 10*1000;
					spec.success = function(data) {
						clear(handle);
						callback(data);
					}
					spec.error = error;
					attempt[handle] = function() {
						$.ajax(spec);
					}
					attempt[handle]();
					return handle;
				}

				return this;
			}

			let internet = new Internet();
			let LevelList = MakeLevelList();
 			let level;
 			let levelPlan;
 			let demoProgress = [];
 			let demoRecords = [];
 			for( let i=0 ; i<Rules.demoLevelLimit ; ++i ) {
 				demoProgress[i] = { time: 3*60 };
 				demoRecords[i]  = { time: 999, userName: 'demo' };
 			}

			let progressGet = function(callback) {
				if( Rules.isDemo ) {
					setTimeout( function() { 
						callback(demoProgress);
					}, 1 );
					return;
				}
				internet.ajax({
					url: '/progressRr',
					method: 'GET',
					contentType:"application/json; charset=utf-8",
					data: {},
				}, callback );
			}

			let progressSave = function(levelNumber,time,callback) {
				if( Rules.isDemo ) {
					setTimeout( function() {
						demoProgress[levelNumber] = { time: time };
						if( time < demoRecords[levelNumber].time ) {
							demoRecords[levelNumber].time = time;
							demoRecords[levelNumber].userName = 'demo';
						}
						callback( { result: 'success' } );
					}, 1 );
					return;
				}

				internet.ajax({
					url: '/progressRr',
					method: 'POST',
					contentType:"application/json; charset=utf-8",
					data: JSON.stringify({
					    level: levelNumber,
					    time: time
					})
				}, callback);
			}

			let recordsGet = function(callback) {

				function doAssign(records) {
					for( let i=0 ; i<LevelList.length ; ++i ) {
						Records.best[i] = records[i];
					}
					callback();
				}

				if( Rules.isDemo ) {
					setTimeout( function() { 
						doAssign(demoRecords);
					}, 1 );
					return;
				}
				internet.ajax({
					url: '/recordsRr',
					method: 'GET',
					contentType:"application/json; charset=utf-8",
					data: {},
				}, doAssign );
			}


			function MakeStars() {
				window.star = [];
				let w = canvasWidth;
				let h = canvasHeight;
				for( let i=0 ; i<150 ; ++i ) {
					let depth = 0.1+Math.random()*0.85;
					window.star[i] = {
						img: Img['star'+randInt(5)],
						x: randInt(w*1.3/depth),
						y: randInt(h*1.3/depth),
						xSpan: (w+randInt(w*0.3)),
						ySpan: (h+randInt(h*0.3)),
						depth: depth
					}
				}
			}

			class Board{
				constructor(size){
					this.size = size;
 					this.earthIsOn = false;
				}
				pickRandomLocation(){
					return Math.random()*this.size-(this.size/2)
				}
				get xMin() { return -this.size/2; }
				get xMax() { return this.size/2; }
				get yMin() { return -this.size/2; }
				get yMax() { return this.size/2; }
				contains(x,y) {
					return x>=this.xMin && x<=this.xMax && y>=this.yMin && y<=this.yMax;
				}
				clamp(x,y) {
					return [Math.min(Math.max(x,this.xMin),this.xMax),Math.min(Math.max(y,this.yMin),this.yMax)];
				}
			}
 			class Sim{
 				constructor(board){
 					this.board = board;
 					this.elapsedTime = 0;
 					this.pieceList = [];

					this.nowPrior = null;
 					this.gameFailLatch = false;

 					for (let i = 0; i < levelPlan.pieceSource.length; i++) {
 						let object = levelPlan.pieceSource[i];
					
						this.addPiece(object.x, object.y, object.type, object)
					}
 				}
				addPiece(x, y, type, object){
					let newPiece;
					if(type == "blower"){
						newPiece = (new Blower(this, x, y))
					}
					if(type == "payload"){
						newPiece = (new Payload(this, x, y))
					}
					if(type == "gate"){
						newPiece = (new Gate(this, x, y))
					}
					if(type == "receptical"){
						newPiece = (new Receptical(this, x, y))
					}
					if(type == "mine"){
						newPiece = (new Mine(this, x, y))
					}
					if(type == "barricade"){
						newPiece = (new Barricade(this, x, y))
					}
					if(type == "destructible"){
						newPiece = (new Destructible(this, x, y))
					}
					if(type == "turret"){
						newPiece = (new Turret(this, x, y, object.fireDelay, object.bulletSpeed))
					}
					if(type == "bullet"){
						newPiece = (new Bullet(this, x, y, object.xVel, object.yVel))
					}
					if(type == "text"){
						newPiece = (new Text(this, x, y, object.text, object.condition))
					}
					return newPiece;
				}
				find(type){
 					return this.pieceList.find((piece)=>piece.type == type);
 				}
 				exists(type){
 					return !!this.find(type);
 				}
 				get blower(){
 					return this.find("blower");
 				}
 				get payload(){
 					return this.find("payload");
 				}
 				tick(dt){
					this.elapsedTime += dt;
					this.pieceList.forEach(piece => piece.tick(dt))
					for (var i = 0; i < this.pieceList.length; i++){
						if(this.pieceList[i].dead && !this.pieceList[i].warping){
							this.pieceList.splice(i, 1)
						}
					}
				}
 				piecesBlown(dt){
 					let blower = this.blower;
 					if(!blower){return}
					if(blower.blowing){
						for(let i = 0; i < this.pieceList.length; i++){
							let piece = this.pieceList[i];
							if(!piece.blowable){
								continue;
							}
							let angle = calcAngle(blower.x, blower.y, piece.x, piece.y);
							let blowArc = degToRad(45);
							let dist = calcDist(blower.x, blower.y, piece.x, piece.y);
							if(isWithinArc(blower.angle, angle, blowArc) && dist < Rules.blowRange){
								let velIncrease = (((Rules.blowRange-calcDist(blower.x, blower.y, piece.x, piece.y))*Rules.blowForce)/piece.mass)*dt;
								piece.xVel -= velIncrease*((blower.x - piece.x)/dist)
								piece.yVel -= velIncrease*((blower.y - piece.y)/dist)
							}
						}
					}else{
						console.log()
					}
				}
 				piecesTouched(){
 					let nextLevel = false;
					this.pieceList.forEach(piece => {
						if(piece.dead || !piece.collider){
							return;
						}
						for(let i = 0; i < this.pieceList.length; i++){
							let piece2 = this.pieceList[i];
							if(piece2.dead || !piece2.collider){
								continue;
							}
							if(piece == piece2){
								continue;
							}
							if(calcDist(piece.x, piece.y, piece2.x, piece2.y) < (piece.hitBoxRadius+piece2.hitBoxRadius)){
								if(piece.onTouch(piece2.effect) == "next level"){
									nextLevel = true;
								}
							}
						}
					})
					if(nextLevel){
						return "next level"
					}
				}
			}

			class Piece{
				constructor(type, sim, x, y, isParticle){
					debug.expect(sim, "object", "sim")
					debug.expectNum(x, "x")
					debug.expectNum(y, "y")
					this.type = type;
					this.sim = sim;
					this.sim.pieceList.push(this);
					this.x = x;
					this.y = y;
					let z;
					if(isParticle){
						z = Rules.zOrders.particle;
					}else{
						z = Rules.zOrders[this.type];
					}
					debug.expectNum(z, "z")
					this.z = z+Math.random();
					this.xVel = 0;
					this.yVel = 0;
					this.mass = 1;
					this.width;
					this.height;
					this.hitBoxRadius;
					this.effect;
					this.collider = true;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.draw(pieceSpec, Img[this.type], camera)
				}
				onTouch(effect){
					if(effect.type == "damage" && !this.warping ){
						this.health -= effect.amount;
					}
					if(effect.type == "win" && this.type == "payload" && !this.warping){
						soundBank.play("warpOut")
						this.x = effect.x;
						this.y = effect.y;
						this.warping = true;
						return "next level";
					}
					if(effect.type == "attach" && this.type == "payload"){
						if(!this.attached){
							soundBank.stop("gameMusic")
							soundBank.playLoop("victoryMusic")
							soundBank.play("woosh")
							soundBank.play("charging")
							setTimeout(()=>{this.sim.board.earthIsOn = true; soundBank.play("turnOn")}, 7500)
							setTimeout(()=>this.sim.blower.credits = true, 12500)
						}
						this.x = effect.x;
						this.y = effect.y;
						this.attached = true;
						this.xVel = 0;
						this.yVel = 0;

					}
				}
				applyVelocity(dt){
					let velocity = Math.sqrt(this.xVel*this.xVel+this.yVel*this.yVel);
					if( velocity > Rules.minSpeed ) {
						this.x += this.xVel*dt*Rules.gameSpeed;
						this.y += this.yVel*dt*Rules.gameSpeed;
					}
				}
				applyFriction(dt){
					this.xVel -= (this.xVel*Rules.friction)*dt*Rules.gameSpeed;
					this.yVel -= (this.yVel*Rules.friction)*dt*Rules.gameSpeed;
				}
				particleTick(){}
				tick(dt){
					this.particleTick(dt);
					if(!this.dead){
						if(this.control == "AI"){
							//this.ai(pieceList);
						}
						this.applyVelocity(dt)

						this.applyFriction(dt)

						if( !this.sim.board.contains(this.x,this.y) && !this.surviveOutOfBounds) {
							this.dead = true;
						}

						if(this.health <= 0 && !this.warping){
							this.dead = true;
						}

						if( this.dead ) {
							if(this.type == "payload" ){
								soundBank.play("explosionBig");
								let temp = this;
								for( let i=0 ; i<7 ; ++i ) {
									setTimeout( function() {
										let x = temp.x + (Math.random()-0.5) * 80;
										let y = temp.y + (Math.random()-0.5) * 80;
										let scale = 0.5+(Math.random()*2.0);
										new Explosion(temp.sim, x, y, temp.xVel/3, temp.yVel/3, scale);
									}, i*0.3 );
								}
							}
							if(this.type == "destructible"){
								soundBank.play("explosionSmall");
								new ExplosionBlue(this.sim, this.x, this.y, this.xVel/3, this.yVel/3)	
							}
						}
					}
				}
			}

			class Payload extends Piece{
				constructor(sim, x, y){
					super("payload", sim, x, y)
					this.mass = 25;
					this.width = 40;
					this.height = 40;
					this.sim = sim;
					this.hitBoxRadius = 20;
					this.blowable = true;
					this.effect = {type: "none"};
					this.health = 10;
					this.warpParticleCount = 0;
					this.warpPhase = 0;
					this.warpDuration = 2;
				}
				particleTick(dt){
					if(this.warpPhase < this.warpDuration){
						this.warpPhase += dt;
						this.xVel = 0;
						this.yVel = 0;
						if(this.warpPhase > 0.5*this.warpDuration){
							this.warpParticleCount = this.warpPhase*15;
						}else{
							this.warpParticleCount = (this.warpDuration-this.warpPhase*2)*15;
						}
						this.warping = true;
					}else{
						this.warping = false;
					}

					for (var i = 0; i < dt*this.warpParticleCount*Rules.gameSpeed; i++) {
						//new Trail(this.sim, this.x+((Math.random()-0.5)*40), this.y+((Math.random()-0.5)*40), 0, 0, 0)
					}

					for (var i = 0; i < dt*10*Rules.gameSpeed; i++) {
						if(Math.random()>0.95){
							new Electricity(this.sim, this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*20), 0, 0, 0)
						}
					}
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					if(true/*this.warpPhase > 0.5*this.warpDuration*/){
						context.draw(pieceSpec, Img[this.type], camera)
					}
				}
			}

			class Gate extends Piece{
				constructor(sim, x, y){
					super("gate", sim, x, y)
					this.width = 150;
					this.height = 150;
					this.hitBoxRadius = 7.5;
					this.blowable = false;
					this.effect = {type: "win", x: this.x, y: this.y};
				}
				/*particleTick(dt){
					let particleAngleMargin = degToRad(90)
					let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
					let velocity = 750;
					let xVel = velocity*Math.cos(particleAngle);
					let yVel = velocity*Math.sin(particleAngle);
					new Force(this.sim, this.x, this.y, xVel, yVel, radToDeg(particleAngle)+180)
				}*/
			}
			class Receptical extends Piece{
				constructor(sim, x, y){
					super("receptical", sim, x, y)
					this.width = 170;
					this.height = 170;
					this.hitBoxRadius = 10;
					this.blowable = false;
					this.effect = {type: "attach", x: this.x, y: this.y};
					this.particleCount = 0;
				}
				particleTick(dt){
					if(this.sim.payload.attached && !this.sim.board.earthIsOn){
						this.particleCount += 0.5;
					}
					for(var i = 0; i < dt*this.particleCount*Rules.gameSpeed; i++) {
						if(Math.random()>0.1){
							new Electricity(this.sim, this.x+((Math.random()-0.5)*40), this.y+((Math.random()-0.5)*40)-50, 0, 0, 0)
						}
					}

				}
			}

 			class Mine extends Piece{
				constructor(sim, x, y){
					super("mine", sim, x, y)
					this.mass = 25;
					this.width = 30;
					this.height = 30;
					this.hitBoxRadius = 15;
					this.blowable = true;
					this.effect = {type: "damage", amount: 10};
				}
			}

			class Barricade extends Piece{
				constructor(sim, x, y){
					super("barricade", sim, x, y)
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 45;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Destructible extends Piece{
				constructor(sim, x, y){
					super("destructible", sim, x, y)
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.health = 1;
					this.collider = true;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
				}
			}
			class Turret extends Piece{
				constructor(sim, x, y, fireDelay, bulletSpeed){
					super("turret",sim, x, y)
					debug.expectNum(fireDelay, "fireDelay")
					debug.expectNum(bulletSpeed, "bulletSpeed")
					this.sim = sim;
					this.width = 100;
					this.height = 100;
					this.hitBoxRadius = 50;
					this.blowable = false;
					this.effect = {type: "damage", amount: 10};
					this.fireDelay = fireDelay;
					this.timeToNextFire = this.fireDelay;
					this.bulletSpeed = bulletSpeed;
					this.angle = 0;
				}
				tick(dt){
					this.particleTick(dt);
					let target = this.sim.payload;
					if(target){
						this.angle = calcAngle(this.x, this.y, target.x, target.y);
					}

					if(this.timeToNextFire <= 0){
						soundBank.play("shot");
						this.timeToNextFire = this.fireDelay;
						let velocity = this.bulletSpeed;
						let xVel = velocity*Math.cos(this.angle);
						let yVel = velocity*Math.sin(this.angle);
						this.sim.addPiece(this.x, this.y, "bullet", {type: "bullet", x: this.x, y: this.y, xVel: xVel, yVel: yVel})
					}else{
						this.timeToNextFire -= dt*Rules.gameSpeed;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					context.drawRotated(pieceSpec, Img.turret, camera, radToDeg(this.angle))
				}
			}
			class Bullet extends Piece{
				constructor(sim, x, y, xVel, yVel){
					super("bullet", sim, x, y)
					debug.expectNum(xVel, "xVel")
					debug.expectNum(yVel, "yVel")
					this.mass = 25;
					this.width = 26;
					this.height = 26;
					this.xVel = xVel;
					this.yVel = yVel;
					this.hitBoxRadius = 15;
					this.blowable = true;
					this.effect = {type: "damage", amount: 10};
				}
				tick(dt){
					this.particleTick(dt);

					this.applyVelocity(dt)

					if( !this.sim.board.contains(this.x,this.y) ) {
						this.dead = true;
					}
				}
			}
			class Text extends Piece{
				constructor(sim, x, y, text, condition){
					super("text", sim, x, y)
					debug.expect(text, "string", "text")
					this.hitBoxRadius = 0;
					this.text = text;
					this.condition = condition;
					this.blowable = false;
					this.effect = {type: "none"};
				}
				draw(context, camera){
					let conditionMet = false;
					if(this.condition == "power" && this.sim.board.earthIsOn){
						conditionMet = true;
					}
					if((!this.condition || conditionMet) && !Cinematic){
						let drawX = this.x-(camera.x-canvasWidth/2);
						let drawY = this.y-(camera.y-canvasHeight/2);
						context.font = "30px Arial";
						context.fillStyle = 'white';
						context.fillText(this.text, drawX, drawY);
					}
				}
			}

 			class Blower extends Piece{
				constructor(sim, x, y, control){
					super("blower", sim, x, y, 1)
					this.width = 50;
					this.height = 50;
					this.hitBoxRadius = 25;
					this.blowable = false;
					this.effect = {type: "none"};
					this.collider = false;
					this.surviveOutOfBounds = true;

					this.control = control;
					this.angle = (Math.random()*Math.PI*2)-Math.PI;
					this.speed = Rules.playerSpeed;
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					let angle = (this.angle/Math.PI)*180
					context.drawRotated(pieceSpec, Img.blower, camera, angle)
				}
				moveTick(dt){
					if(wDown){
						this.y -= this.speed*dt*Rules.gameSpeed;
					}
					if(sDown || this.credits){
						this.y += this.speed*dt*Rules.gameSpeed;
					}
					if(aDown || (this.credits && this.x > 0)){
						this.x -= this.speed*dt*Rules.gameSpeed;
					}
					if(dDown || (this.credits && this.x < 0)){
						this.x += this.speed*dt*Rules.gameSpeed;
					}
					[this.x,this.y] = this.sim.board.clamp(this.x,this.y);
				}
				particleTick(dt){
					if(Rules.gameSpeed){
						new Trail(this.sim, this.x+((Math.random()-0.5)*20), this.y+((Math.random()-0.5)*10), 0, 0, 0)
					}
					if(this.blowing){
						for (var i = 0; i < 100*dt*Rules.gameSpeed; i++) {
							let particleAngleMargin = degToRad(90)
							let particleAngle = this.angle+((Math.random()-0.5)*particleAngleMargin)
							let velocity = 750;
							let xVel = velocity*Math.cos(particleAngle);
							let yVel = velocity*Math.sin(particleAngle);
							new Force(
								this.sim, 
								this.x, 
								this.y, 
								xVel, 
								yVel, 
								radToDeg(particleAngle)+180, 
								this
							);
						}
					}
				}
				ai(pieceList){
					let directionList = ["up", "down", "left", "right"]
					
				}
				tick(dt){
					this.moveTick(dt);
					this.particleTick(dt)
					if(this.health <= 0 && !this.warping){
						this.dead = true;
					}
				}
				grow(amount){
					this.length += amount*Rules.growSpeedMod*(this.speed+this.tempSpeed)/100;
				}
				speedBoost(amount){
					this.tempSpeed += amount*Rules.speedBoostMod;
				}
				strengthen(amount){
					this.strength += amount*Rules.strengthAddMod;
				}
				setTarget(x, y){
					this.angle = calcAngle(this.x, this.y, x, y);
				}
			}

			class Particle extends Piece{
				constructor(type, sim, x, y, xVel, yVel, angle=0, parent=null){
					super(type, sim, x, y, true)
					this.width = 5;
					this.height = 5;
					this.xVel = xVel;
					this.yVel = yVel;
					this.blowable = false;
					this.collider = false;
					this.lifeRemaining = Rules.blowRange/(xVel+yVel);
					this.angle = angle;
					if( parent ) {
						this.parent = parent;
						this.px = this.parent.x;
						this.py = this.parent.y;
					}
				}
				draw(context, camera){
					let pieceSpec = {
						x: this.x,
						y: this.y,
						width: this.width,
						height: this.height,
						xAnchor: 0.5,
						yAnchor: 0.5
					};
					if(this.angle == 0){
						context.draw(pieceSpec, Img[this.type], camera)
					}else{
						context.drawRotated(pieceSpec, Img[this.type], camera, this.angle)
					}
				}
				tick(dt){
					if(!this.dead){
						if( this.parent ) {
							let pdx = this.parent.x - this.px;
							let pdy = this.parent.y - this.py;
							this.x += pdx;
							this.y += pdy;
							this.px = this.parent.x;
							this.py = this.parent.y;
						}

						this.applyVelocity(dt)

						this.lifeRemaining -= dt*Rules.gameSpeed;
						if(this.lifeRemaining <= 0){
							this.dead = true;
						}
					}
				}
			}
			class Force extends Particle{
				constructor(sim, x, y, xVel, yVel, angle, parent){
					super("force", sim, x, y, xVel, yVel, angle, parent)
					this.width = 40;
					this.height = 10;
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Trail extends Particle{
				constructor(sim, x, y, xVel, yVel){
					super("trail", sim, x, y, xVel, yVel)
					this.width = 5;
					this.height = 5;
					this.angle = Math.random()*360;
					this.lifeRemaining = (Math.random()+0.5)*0.2;
				}
			}
			class Electricity extends Particle{
				constructor(sim, x, y, xVel, yVel){
					super("electricity", sim, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.lifeRemaining = Math.random()*0.2;
				}
			}
			class PortalEnergy extends Particle{
				constructor(sim, x, y, xVel, yVel){
					super("portalEnergy", sim, x, y, xVel, yVel)
					this.width = 20;
					this.height = 20;
					this.angle = Math.random()*360;
					this.lifeRemaining = 0.5;
				}
			}
			class ExplosionGeneric extends Particle{
				constructor(type, sim, x, y, xVel, yVel, scale=1.0){
					super(type, sim, x, y, xVel, yVel)
					this.width = 200;
					this.height = 200;
					this.angle = 0;
					this.totalLife = 0.52;
					this.lifeRemaining = this.totalLife;
					this.img = Img[this.type];
					this.scale = scale;
				}
				draw(context, camera){
					let frameCount = 13;
					let frame = Math.floor(((this.totalLife-this.lifeRemaining)/this.totalLife)*frameCount) //12 frames in the explosion image.
					let frameWidth = 2548/frameCount;
					let frameHeight = 190;

					let pieceSpec = {
						sx: frame*frameWidth,
						sy: 0,
						sw: frameWidth,
						sh: frameHeight,
						x: this.x,
						y: this.y,
						width: this.width*this.scale,
						height: this.height*this.scale,
						xAnchor: 0.5,
						yAnchor: 0.5
					};

					context.draw(pieceSpec, this.img, camera)
				}
			}
			class Explosion extends ExplosionGeneric {
				constructor(sim, x, y, xVel, yVel, scale=1.0){
					super("explosion",sim,x,y,xVel,yVel,scale);
				}
			}
			class ExplosionBlue extends ExplosionGeneric{
				constructor(sim, x, y, xVel, yVel, scale=0.8){
					super("explosionBlue",sim,x,y,xVel,yVel,scale);
				}
			}
 			//CONTROL
 			let wDown;
 			let sDown;
			let aDown;
			let dDown;
			function initControls(sim){
				let blower = sim.pieceList[0];
				let mouseX = 0;
				let mouseY = 0;
				$( document ).on("mousemove.controls", null, function( event ) {
					mouseX = event.pageX+blower.x-canvasWidth/2;
					mouseY = event.pageY+blower.y-canvasHeight/2;
					blower.setTarget(mouseX, mouseY)
				});
				$( document ).on("mousedown.controls", null,function( event ) {
					soundBank.playLoop("repulse");
					blower.blowing = true;
				});
				$( document ).on("mouseup.controls", null, function( event ) {
					soundBank.stop("repulse");
					blower.blowing = false;
				});
				$( document ).on("keydown.controls", null, function( event ) {
					if(event.key == "w" || event.key == "W"){
						wDown = true;
					}
					if(event.key == "s" || event.key == "S"){
						sDown = true;
					}
					if(event.key == "a" || event.key == "A"){
						aDown = true;
					}
					if(event.key == "d" || event.key == "D"){
						dDown = true;
					}
					if(event.key == "Escape"){
						if(Rules.gameSpeed){
							PauseGame(sim.elapsedTime)
							console.log("pause")
						}else{
							UnpauseGame()
							console.log("unpause")
						}
					}
					if(level == 0){
						if(event.key == "0"){
							EditLevel(sim, levelPlan, "deletePiece")
						}
						if(event.key == "1"){
							EditLevel(sim, levelPlan, "blower", mouseX, mouseY)
						}
						if(event.key == "2"){
							EditLevel(sim, levelPlan, "gate", mouseX, mouseY)
						}
						if(event.key == "3"){
							EditLevel(sim, levelPlan, "payload", mouseX, mouseY)
						}
						if(event.key == "4"){
							EditLevel(sim, levelPlan, "barricade", mouseX, mouseY)
						}
						if(event.key == "5"){
							EditLevel(sim, levelPlan, "mine", mouseX, mouseY)
						}
						if(event.key == "6"){
							EditLevel(sim, levelPlan, "destructible", mouseX, mouseY)
						}
						if(event.key == "7"){
							EditLevel(sim, levelPlan, "turret", mouseX, mouseY)
						}
					}
				});
				$( document ).on("keyup.controls", null, function( event ) {
					if(event.key == "w" || event.key == "W"){
						wDown = false;
					}
					if(event.key == "s" || event.key == "S"){
						sDown = false;
					}
					if(event.key == "a" || event.key == "A"){
						aDown = false;
					}
					if(event.key == "d" || event.key == "D"){
						dDown = false;
					}
					
				});

			}
 			//VIEW
 			let ImageURLs = {
				blower: 'images/mover.png',
				payload: 'images/payload.png',
				gate: 'images/gate.png',
				receptical: 'images/receptical.png',
				mine: 'images/mine.png',
				barricade: 'images/barricade.png',
				destructible: 'images/destructible.png',
				turret: 'images/turret.png',
				bullet: 'images/bullet.png',
				background: 'images/black.png',
				earthOff: 'images/earthOff.png',
				earthOn: 'images/earthOn.png',
				force: 'images/particles/force2.png',
				trail: 'images/particles/trail.png',
				electricity: 'images/particles/lightning.png',
				portalEnergy: 'images/particles/trail.png',
				explosion: 'images/explosion.png',
				explosionBlue: 'images/explosionBlue.png',
				star0: 'images/star0.png',
				star1: 'images/star1.png',
				star2: 'images/star2.png',
				star3: 'images/star3.png',
				star4: 'images/star4.png',
				//minimapBackground: 'images/minimapBackground.jpg',
			};
 			let Img = {};
 			class View{
				constructor(){
 				}
				
 				loadFiles(imageURLs, target, callbackFn){
					let imagesRequested = 0;
					let imagesLoaded = 0;

					soundBank = new SoundBank();
					soundBank.load("explosionBig","sound/explosionBig.mp3");
					soundBank.load("explosionSmall","sound/explosionSmall2.wav");
					soundBank.load("shot","sound/shot.wav", 0.5);
					soundBank.load("click","sound/click.mp3", 3);
					soundBank.load("charging","sound/charging.wav", 0.75);
					soundBank.load("turnOn","sound/turnOn.mp3", 4);
					soundBank.load("warpIn","sound/warpIn.wav", 3);
					soundBank.load("warpOut","sound/warpOut.wav", 5);
					soundBank.load("woosh","sound/sunDiscThrowerImpact.wav");
					soundBank.loadLoop("repulse",{
						src: "sound/repulse.wav",
						loop: true,
						volume: Rules.volume*2,
						sprite: {
							main: [0, 10000, true]
						}
					});
					soundBank.loadLoop("menuMusic",{
						src: "sound/music/ThemeMusicElectro.wav",
						loop: true,
						volume: Rules.musicVolume*10,
						sprite: {
							main: [0, 100000, true]
						}
					});
					soundBank.loadLoop("gameMusic",{
						src: "sound/music/ThemeMusicArcade.wav",
						loop: true,
						volume: Rules.musicVolume,
						sprite: {
							main: [0, 100000, true]
						}
					});
					soundBank.loadLoop("victoryMusic",{
						src: "sound/music/ThemeHeroic.mp3",
						loop: true,
						volume: Rules.musicVolume*5,
						sprite: {
							main: [0, 100000, true]
						}
					});

					for(let key in imageURLs){
						let image = imageURLs[key];
						target[key] = new Image();
						target[key].onload = function(){
							imagesLoaded ++
						};
						target[key].src = image;
						imagesRequested ++;
					}
 					let handle = setInterval( () => {
						if( imagesLoaded >= imagesRequested ) {
							console.assert(imagesLoaded == imagesRequested)
							clearInterval(handle);
							callbackFn();
						}
					},1)
				}
 				myCanvas(canvasId, board){
					var canvas = document.getElementById(canvasId);
					var context = canvas.getContext('2d');
					context.canvas.width = window.innerWidth;
					context.canvas.height = window.innerHeight;
					
					context.draw = function(spec, imageObj, camera){
						let drawX = spec.x-(camera.x-canvasWidth/2);
						let drawY = spec.y-(camera.y-canvasHeight/2);
						if(spec.xAnchor && spec.yAnchor){
							drawX -= spec.width*spec.xAnchor;
							drawY -= spec.height*spec.yAnchor;
						}
						if(spec.sx !== undefined){
							this.drawImage(imageObj, spec.sx, spec.sy, spec.sw, spec.sh, drawX, drawY, spec.width, spec.height);
						}else{
							this.drawImage(imageObj, drawX, drawY, spec.width, spec.height);
						}
					}.bind(context)
					context.clear = function(sim){
						if( levelPlan.backgroundImg && levelPlan.backgroundImg.complete ) {
							let img = levelPlan.backgroundImg;
							let xPct = (sim.blower.x - board.xMin) / (board.size + context.canvas.width);
							let yPct = (sim.blower.y - board.yMin) / (board.size + context.canvas.height);
							let bx = img.width * 0.40 * xPct;
							let by = img.height * 0.40 * yPct;
							let bw = img.width * 0.60;
							let bh = img.height * 0.60;
							this.drawImage(img, bx, by, bw, bh, 0, 0, canvas.width, canvas.height);
						}
						else {
							let backgroundName = levelPlan.background ? (board.earthIsOn ? "earthOn" : "earthOff") : "background";
							let backgroundImg = Img[backgroundName];
							this.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
						}

						for( let i=0 ; i<window.star.length ; ++i ) {
							let star = window.star[i];
							let sx = ((star.x-sim.blower.x) * star.depth) % star.xSpan;
							let sy = ((star.y-sim.blower.y) * star.depth) % star.ySpan;
							this.drawImage(star.img,sx,sy,star.img.width,star.img.height);
						}
					
					}.bind(context)
					/*context.clearMinimap = function(spec, imageObj){
						this.drawImage(Img.background, 0, 0, 280, 260);
					}.bind(context)*/
					context.drawRotated = function(spec, imageObj, camera, degrees){
						let x = spec.x-(camera.x-canvasWidth/2);
						let y = spec.y-(camera.y-canvasHeight/2);
						x -= spec.width*spec.xAnchor;
						y -= spec.height*spec.yAnchor;
						
						let w = spec.width;
						let h = spec.height;

						this.save();
						this.translate(x+w/2, y+h/2);
						this.rotate(degrees*Math.PI/180.0);
						this.translate(-x-w/2, -y-h/2);
						this.drawImage(imageObj, x, y, w, h);
						this.restore();
					}.bind(context)
					return context
				}
 				render(context, sim){
					context.clear(sim);
 					let camera = {};
 					camera.x = sim.blower.x;
					camera.y = sim.blower.y;
					sim.pieceList.sort(function(a, b){return b.z - a.z});
 					for(let i = 0; i < sim.pieceList.length; i++){
						
						if(!sim.pieceList[i].dead){
							sim.pieceList[i].draw(context, camera)
						}
					}
				}
			}
 			//ORGANIZATION
 			function getTimeTable(elapsedTime,andCounting) {
 				let time = timeReadable(elapsedTime); //this is to get just 1 decimal point of detail.
				let timeYou = Records.you[level] && Records.you[level].time ? timeReadable(Records.you[level].time) : '?.?';
				let timeBest = Records.best[level] && Records.best[level].time ? timeReadable(Records.best[level].time) : '?.?';
				let userBest = Records.best[level] && Records.best[level].userName ? Records.best[level].userName : '';
				let s = ''+
					'<div>'+
					'<table class="timeTable ctrMargin"><tr><td>Current time:</td><td class="right">'+time+'</td><td>'+(andCounting?'and counting':'seconds')+'</td></tr>'+
					'<tr><td>Your best:</td><td class="right">'+timeYou+'</td><td>seconds</td></tr>'+
					'<tr><td>Record:</td><td class="right">'+timeBest+'</td><td> by '+userBest+'</td></tr>'+
					'</div>'
				;
				return s;
			}

			function displayTitleScreen(){
				$("#canvas").hide()
				$("#brief").hide()
				$("#overlayMenu").hide()
				$("#levelSelect").hide()
				$("#menus").show()
				$("#titleScreen").show()
			}
			function displayLevelSelect(progress){
				$("#gameOverScreen").hide()
				$("#titleScreen").hide()
				$("#levelSelect").show()
				$("#levelRoster").empty();

				for (let i = 0; i < LevelList.length; i++) {
					let levelDisable = (i>0 && progress[i] === undefined);
					let cls 	= levelDisable ? ' levelDisable' : '';
					let action 	= levelDisable ? '' : 'onClick="startGameMusic(); GameStart('+i+');"';
					$("#levelRoster").append(
						'<button class="menuButton levelButton '+cls+'" '+action+'>'+(i+1)+'</button>'
					);
					if((i+1)%10 == 0){
						$("#levelRoster").append('<br>');
					}
				}
				$("#levelBuilder").toggle(Rules.showLevelBuilder);
			}
			function displayGameOverScreen(win, elapsedTime){
				$("#levelSelect").hide()
				$('#gameWin').hide();
				$('#gameLose').hide();
 				$('button').off(".gameOver");

				$('.buttonMainMenu').on( 'click.gameOver', null, () => {
					GameClear();
					startMenuMusic();
					displayTitleScreen();
				});
				$('.buttonPlayAgain').on( 'click.gameOver', null, () => {
					GameClear();
					GameStart(level)
				});
				$('.buttonNextLevel').on( 'click.gameOver', null, () => {
					GameClear();
					GameStart(level+1);
				});

				if(win){
					let time = timeReadable(elapsedTime); //this is to get just 1 decimal point of detail.
					let isPersonalBest = !Records.you[level] || !Records.you[level].time || elapsedTime < Records.you[level].time;
					let isRecord = !Records.best[level] || !Records.best[level].time || elapsedTime < Records.best[level].time;

					let notify = isRecord ? 'You set the World Record!!!' : (isPersonalBest ? 'A new Personal Best!' : '');
					if( notify ) {
						notify += '<div class="spacer"></div>';
					}

					$('#gameSummaryWin').html(
						'Level '+(level+1)+' completed in '+time+' seconds!<br />'+
						'<div class="spacer"></div>'+
						notify+
						getTimeTable(elapsedTime,false)
					);
					$('#gameWin').show();
					$('#gameWin button').hide();
					$('#gameSaving').show();
					progressSave( level, elapsedTime, function() {
						$('#gameSaving').hide();
						$('#gameWin button').show();
						let showNextLevel = (!Rules.isDemo || level+1 < Rules.demoLevelLimit);
						$(".buttonNextLevel").toggle(showNextLevel);
					});
				}else{
					$('#gameSummaryLose').html('Level '+(level+1)+' failed!');
					$('#gameLose').show();
				}
				$("#pauseMenu").hide()
				$("#gameOverScreen").show()
				$("#overlayMenu").show()
			}
			function displayBrief(){
				$("#titleScreen").hide()
				$("#brief").show()
			}
 			function GameOver(){
 				soundBank.stop("repulse");
 				$(document).off(".controls")
 			}
 			function GameClear(){
 				window.animateView = false;
 				clearInterval(handleInterval);
 				handleInterval = null;
 				cancelAnimationFrame(handleView)
 				handleView = null;

			}
			function startGameMusic(){
				soundBank.stopAll();
				soundBank.playLoop("gameMusic");
			}
			function startMenuMusic(){
				soundBank.stopAll();
				soundBank.playLoop("menuMusic");
			}
			function PauseGame(elapsedTime){
				Rules.gameSpeed = 0;
				$("#restartLevelButton").click(
					()=>{
						GameOver();
						GameClear();
						GameStart(level);
					}
				)
				$("#pauseMenuText").html(
					'Level '+(level+1)+' paused.<br />'+
					'<div class="spacer"></div>'+
					getTimeTable(elapsedTime,true)
				);
				$("#gameOverScreen").hide();
				$("#pauseMenu").show();
				$("#overlayMenu").show()

			}
			function UnpauseGame(){
				Rules.gameSpeed = 0.5;
				$("#overlayMenu").hide()
			}

			let timeFail = 9999;

			function GameStart(forceLevel) {
				progressGet( function(progress) {
					var i = 0;
					while(progress[i] && progress[i].time < timeFail && i < LevelList.length-1){
						Records.you[i] = Records.you[i] || {};
						Records.you[i].time = progress[i].time;
						i ++;
					}
					if( forceLevel !== undefined && forceLevel !== null ) {
						i = forceLevel;
					}
					GameMain(i);
				});
			}

 			function GameMain(newLevel){
 				soundBank.play("warpIn")
				UnpauseGame()
				//level = prompt("Which level would you like to play?");
				wDown = false;
				sDown = false;
				aDown = false;
				dDown = false;

				$("#menus").hide()
				$("#canvas").show()
				level = newLevel;
				levelPlan = LevelList[level];
				let view = new View();
				let board = new Board(levelPlan.boardSize || Rules.boardSize);
				let context = view.myCanvas('canvas', board);
				let sim = new Sim(board);
				initControls(sim);
				if( levelPlan.backgroundUrl ) {
					levelPlan.backgroundImg = new Image();
					levelPlan.backgroundImg.src = levelPlan.backgroundUrl;
				}
				
				function tickSim(){
					if( !sim.gameFailLatch && !sim.payload){
						sim.gameFailLatch = true;
						setTimeout(() => {
							GameOver()
							displayGameOverScreen(false, sim.elapsedTime)
						},2000)
					}

					sim.timeSinceLastSim = 0;
					let dt;
					let now = Date.now();
					if(sim.nowPrior === null){
						dt = 1.0/FPS;
					}else{
						dt = (now - sim.nowPrior)/1000;
					}
					sim.nowPrior = now;
					sim.timeSinceLastSim += dt;
					while(sim.timeSinceLastSim > 1/FPS){
						sim.piecesBlown(dt);
						if(sim.piecesTouched() == "next level"){
							return "next level"
						}
						sim.tick(1/FPS);
						sim.timeSinceLastSim -= 1/FPS;
					}
				}
 				function tickView(){
					view.render(context, sim);
					//view.renderMinimap(context, sim);
				}

				$("#titleScreen").hide()

				let animDone = true;
				let avLatch = false;
				function animateView(){
					//console.log('animView');
					tickView()
					if(tickSim() == "next level" && !avLatch ){
						avLatch = true;
						setTimeout(
							()=>{
								soundBank.play("woosh")
								GameOver()
								displayGameOverScreen(true, sim.elapsedTime)
							}, 4000
						)
					}
					//console.log('animView request');
					animDone = true;
				}
				debug.assert( !window.animateView );
				window.animateView = true;
				//console.log('animView start');
 				animateView();
 				function silly() {
 					if( animDone ) {
 						animDone = false;
						handleView = requestAnimationFrame( animateView );
					}
				}
				handleInterval = setInterval( silly, 1 );

			}

			function onResize() {
				let canvasId = "canvas"
				let canvas = document.getElementById(canvasId);
				if( !canvas ) return;
				let context = canvas.getContext('2d');
				if( !context ) return;
				context.canvas.width = window.innerWidth;
				context.canvas.height = window.innerHeight;
 				canvasWidth = context.canvas.width;
				canvasHeight = context.canvas.height;
				console.assert(canvasWidth > 0)
				console.assert(canvasHeight > 0)
				MakeStars(context);
			}

			$(document).ready(function(){
				if(Cinematic){
					document.getElementById("canvas").style.cursor = "none";
				}

				let view = new View();
				$('#loading').show();
				$('#titleButtons').hide();
				view.loadFiles(ImageURLs, Img, function() {
					recordsGet( function() {
						$('#loading').hide();
						$('#titleButtons').show();
						startMenuMusic()
						displayTitleScreen();
					});
				});
				onResize();
				
				$(window).resize( onResize );
				setInterval( function() {
					$('#demoNote').toggle(Rules.isDemo);
				}, 5*1000);
			});
			
	</script>
  </body>
</html>		
		</script>
	</head>
	<body>
		<div id="demoNote" class="hide"><div>DEMO</div></div>
		<div id="menus" class="ctr">
			<div id="menuBg">
				<img src='images/monitor.jpg'>
			</div>
			<div id="titleScreen" class="menu">
				<h1 class="menuTitle">
					Reactor Rescue
				</h1>
				<div class='spacer2x'></div>
				<div id="loading">Loading...</div>
				<div id="titleButtons">
					<button class="bigMenuButton" onClick="startGameMusic(); GameStart();">
						Play
					</button>
					<div class='spacer2x'></div>
					<button class="menuButton" onClick="displayBrief()">
						Briefing
					</button>
					<div class='spacer'></div>
					<button class="menuButton" onClick="progressGet(displayLevelSelect);">
						Level Select
					</button>
				</div>
			</div>
			<div id="brief" class="menu hide">
				<h1 class="menuTitle">
					Your Mission
				</h1>
				<div class="menuText">
					<p>
						The enemy has stolen the Quantum Arc-Reactor and placed it deep behind enemy lines!
						You must return it to High Command.
					</p>
					<p>
						WARNING: The Arc-Reactor is unstable!
						If it touches anything, it will go critical and Earth's most valuable asset will be destroyed.
					</p>
					<p>
						We can warp you in.
						Use your repulser to push the Arc-Reactor through the blue warp gates.
					</p>
					<p>
						Good Luck, Captain.
					</p>
				</div>
				<button class="menuButton" onClick="displayTitleScreen()">
					Understood
				</button>
			</div>
			<div id="levelSelect" class="menu hide">
				<h1 class="menuTitle">
					Choose A Level
				</h1>
				<div class="spacer"></div>
				<div id="levelRoster">
				</div>
				<div class="spacer"></div>
				<button id="levelBuilder" class="menuButton" onClick="StartEditor();">Level Builder</button>
				<div class="spacer"></div>
				<button class="menuButton" onClick="displayTitleScreen()">Back</button>
			</div>
		</div>
		<div id="canvasDiv" width="100%" height="100%">
			<div id="overlayMenu">
				<div id="pauseMenu">
					<h1 class="menuTitle pauseMenuTitle">
						Game Paused
					</h1>
					<div id="pauseMenuText" class="menuText ctr"></div>
					<div class="spacer"></div>
					<div class="ctr">
						<button class="menuButton" onclick="UnpauseGame()">
							Resume Game
						</button>
						<button class="menuButton" id="restartLevelButton">
							Restart Level
						</button>
						<button class="menuButton" onclick="GameOver(); GameClear(); startMenuMusic(); displayTitleScreen();">
							Main Menu
						</button>
					</div>
				</div>
				<div id="gameOverScreen" class="menu hide">
					<div id="gameWin">
						<h1 class="menuTitle ctr">Level Complete!</h1>
						<div class="spacer"></div>
						<div id="gameSummaryWin" class="menuText ctr"></div>
						<div class="spacer"></div>
						<div id='gameSaving' class="ctr">
							Saving...
						</div>
						<div class="ctr">
							<button class="buttonMainMenu menuButton">Main Menu</button>
							<button class="buttonPlayAgain menuButton">Play Again</button>
							<button class="buttonNextLevel menuButton">Next Level</button>
						</div>
					</div>
					<div id="gameLose">
						<h1 class="menuTitle ctr">Reactor Destroyed!</h1>
						<div class="spacer"></div>
						<div id="gameSummaryLose" class="menuText ctr"></div>
						<div class="spacer"></div>
						<div class="ctr">
							<button class="buttonMainMenu menuButton">Main Menu</button>
							<button class="buttonPlayAgain menuButton">Try Again</button>
						</div>
					</div>
				</div>

			</div>
			<canvas id="canvas" width="100%" height="100%"></canvas>
		</div>
	</body>
</html>